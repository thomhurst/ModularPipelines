using System.Text;
using ModularPipelines.OptionsGenerator.Models;

namespace ModularPipelines.OptionsGenerator.Generators;

/// <summary>
/// Generates strongly-typed C# options classes following ModularPipelines conventions.
/// </summary>
public class OptionsClassGenerator : ICodeGenerator
{
    public Task<IReadOnlyList<GeneratedFile>> GenerateAsync(CliToolDefinition tool, CancellationToken cancellationToken = default)
    {
        var files = new List<GeneratedFile>();

        foreach (var command in tool.Commands)
        {
            var content = GenerateOptionsClass(command, tool);
            var fileName = $"{command.ClassName}.cs";
            var relativePath = Path.Combine(tool.OutputDirectory, "Generated", "Options", fileName);

            files.Add(new GeneratedFile
            {
                RelativePath = relativePath,
                Content = content
            });
        }

        return Task.FromResult<IReadOnlyList<GeneratedFile>>(files);
    }

    private static string GenerateOptionsClass(CliCommandDefinition command, CliToolDefinition tool)
    {
        var sb = new StringBuilder();

        // File header
        GenerateFileHeader(sb, command.DocumentationUrl);

        // Usings
        sb.AppendLine("using System.Diagnostics.CodeAnalysis;");
        sb.AppendLine("using ModularPipelines.Attributes;");

        if (command.Options.Any(o => o.IsKeyValue))
        {
            sb.AppendLine("using ModularPipelines.Models;");
        }

        if (command.Options.Any(o => o.ValidationConstraints is not null))
        {
            sb.AppendLine("using System.ComponentModel.DataAnnotations;");
        }

        sb.AppendLine();

        // Namespace
        sb.AppendLine($"namespace {tool.TargetNamespace}.Generated.Options;");
        sb.AppendLine();

        // XML documentation
        if (!string.IsNullOrEmpty(command.Description))
        {
            sb.AppendLine("/// <summary>");
            sb.AppendLine($"/// {EscapeXmlComment(command.Description)}");
            sb.AppendLine("/// </summary>");
        }

        // Class attributes
        sb.AppendLine("[ExcludeFromCodeCoverage]");

        if (command.CommandParts.Length > 0)
        {
            var args = string.Join(", ", command.CommandParts.Select(p => $"\"{p}\""));
            sb.AppendLine($"[CommandPrecedingArguments({args})]");
        }

        // Class declaration
        GenerateClassDeclaration(sb, command);

        sb.AppendLine("{");

        // Constructor if needed
        if (command.CommandParts.Length > 0 || command.PositionalArguments.Any(p => p.IsRequired))
        {
            GenerateConstructor(sb, command);
        }

        // Properties for non-required options
        foreach (var option in command.Options.Where(o => !o.IsRequired))
        {
            GenerateProperty(sb, option);
            sb.AppendLine();
        }

        // Positional arguments
        foreach (var positional in command.PositionalArguments.Where(p => !p.IsRequired))
        {
            GeneratePositionalArgument(sb, positional);
            sb.AppendLine();
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateFileHeader(StringBuilder sb, string? documentationUrl)
    {
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine($"// This file was generated by ModularPipelines.OptionsGenerator on {DateTime.UtcNow:yyyy-MM-dd}.");
        if (!string.IsNullOrEmpty(documentationUrl))
        {
            sb.AppendLine($"// Source: {documentationUrl}");
        }
        sb.AppendLine("// Do not edit this file manually.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
    }

    private static void GenerateClassDeclaration(StringBuilder sb, CliCommandDefinition command)
    {
        var requiredOptions = command.RequiredOptions;
        var requiredPositionals = command.PositionalArguments.Where(p => p.IsRequired).ToList();

        if (requiredOptions.Count > 0 || requiredPositionals.Count > 0)
        {
            // Use primary constructor for required parameters
            var parameters = new List<string>();

            foreach (var opt in requiredOptions)
            {
                var attr = GetAttributeString(opt);
                parameters.Add($"    [property: {attr}] {opt.CSharpType.TrimEnd('?')} {opt.PropertyName}");
            }

            foreach (var pos in requiredPositionals)
            {
                var posAttr = GetPositionalAttributeString(pos);
                parameters.Add($"    [property: {posAttr}] {pos.CSharpType.TrimEnd('?')} {pos.PropertyName}");
            }

            sb.AppendLine($"public record {command.ClassName}(");
            sb.AppendLine(string.Join(",\n", parameters));
            sb.AppendLine($") : {command.ParentClassName}");
        }
        else
        {
            sb.AppendLine($"public record {command.ClassName} : {command.ParentClassName}");
        }
    }

    private static void GenerateConstructor(StringBuilder sb, CliCommandDefinition command)
    {
        if (command.RequiredOptions.Count == 0 && !command.PositionalArguments.Any(p => p.IsRequired))
        {
            // Simple constructor that sets CommandParts
            sb.AppendLine($"    public {command.ClassName}()");
            sb.AppendLine("    {");
            if (command.CommandParts.Length > 0)
            {
                var parts = string.Join(", ", command.CommandParts.Select(p => $"\"{p}\""));
                sb.AppendLine($"        CommandParts = [{parts}];");
            }
            sb.AppendLine("    }");
            sb.AppendLine();
        }
    }

    private static void GenerateProperty(StringBuilder sb, CliOptionDefinition option)
    {
        // XML documentation
        if (!string.IsNullOrEmpty(option.Description))
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// {EscapeXmlComment(option.Description)}");
            sb.AppendLine("    /// </summary>");
        }

        // Validation attributes
        if (option.ValidationConstraints is not null)
        {
            GenerateValidationAttributes(sb, option.ValidationConstraints);
        }

        // Command attribute
        var attribute = GetAttributeString(option);
        sb.AppendLine($"    [{attribute}]");

        // Property
        var virtualKeyword = option.IsFlag ? "virtual " : "";
        sb.AppendLine($"    public {virtualKeyword}{option.CSharpType} {option.PropertyName} {{ get; set; }}");
    }

    private static void GenerateValidationAttributes(StringBuilder sb, CliValidationConstraints constraints)
    {
        if (constraints.MinValue.HasValue || constraints.MaxValue.HasValue)
        {
            var min = constraints.MinValue ?? int.MinValue;
            var max = constraints.MaxValue ?? int.MaxValue;
            sb.AppendLine($"    [Range({min}, {max})]");
        }

        if (!string.IsNullOrEmpty(constraints.Pattern))
        {
            sb.AppendLine($"    [RegularExpression(@\"{constraints.Pattern}\")]");
        }
    }

    private static string GetAttributeString(CliOptionDefinition option)
    {
        return option.AttributeType switch
        {
            OptionAttributeType.BooleanCommandSwitch =>
                $"BooleanCommandSwitch(\"{option.SwitchName}\")",
            OptionAttributeType.CommandEqualsSeparatorSwitch when option.ValueSeparator != "=" =>
                $"CommandEqualsSeparatorSwitch(\"{option.SwitchName}\", SwitchValueSeparator = \"{option.ValueSeparator}\")",
            OptionAttributeType.CommandEqualsSeparatorSwitch =>
                $"CommandEqualsSeparatorSwitch(\"{option.SwitchName}\")",
            _ =>
                $"CommandSwitch(\"{option.SwitchName}\")"
        };
    }

    private static void GeneratePositionalArgument(StringBuilder sb, CliPositionalArgument positional)
    {
        if (!string.IsNullOrEmpty(positional.Description))
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// {EscapeXmlComment(positional.Description)}");
            sb.AppendLine("    /// </summary>");
        }

        var attrString = GetPositionalAttributeString(positional);
        sb.AppendLine($"    [{attrString}]");
        sb.AppendLine($"    public {positional.CSharpType} {positional.PropertyName} {{ get; set; }}");
    }

    private static string GetPositionalAttributeString(CliPositionalArgument positional)
    {
        var parts = new List<string>();

        parts.Add($"Position = Position.{positional.Position}");

        if (!string.IsNullOrEmpty(positional.PlaceholderName))
        {
            parts.Add($"PlaceholderName = \"{positional.PlaceholderName}\"");
        }

        return $"PositionalArgument({string.Join(", ", parts)})";
    }

    private static string EscapeXmlComment(string text)
    {
        return text
            .Replace("&", "&amp;")
            .Replace("<", "&lt;")
            .Replace(">", "&gt;")
            .Replace("\r\n", " ")
            .Replace("\n", " ")
            .Replace("\r", " ")
            .Trim();
    }
}
