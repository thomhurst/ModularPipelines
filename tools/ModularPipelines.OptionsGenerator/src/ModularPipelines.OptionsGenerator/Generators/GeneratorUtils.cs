using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;

namespace ModularPipelines.OptionsGenerator.Generators;

/// <summary>
/// Shared utilities for code generators.
/// Centralizes common functionality to avoid DRY violations.
/// </summary>
public static partial class GeneratorUtils
{
    /// <summary>
    /// Escapes text for use in XML documentation comments.
    /// </summary>
    public static string EscapeXmlComment(string text)
    {
        if (string.IsNullOrEmpty(text))
        {
            return string.Empty;
        }

        return text
            .Replace("&", "&amp;")
            .Replace("<", "&lt;")
            .Replace(">", "&gt;")
            .Replace("\r\n", " ")
            .Replace("\n", " ")
            .Replace("\r", " ")
            .Trim();
    }

    /// <summary>
    /// Generates a standard auto-generated file header.
    /// </summary>
    /// <param name="sb">The StringBuilder to append to.</param>
    /// <param name="sourceUrl">Optional documentation source URL.</param>
    public static void GenerateFileHeader(StringBuilder sb, string? sourceUrl = null)
    {
        ArgumentNullException.ThrowIfNull(sb);

        sb.AppendLine("// <auto-generated>");
        sb.AppendLine($"// This file was generated by ModularPipelines.OptionsGenerator on {DateTime.UtcNow:yyyy-MM-dd}.");
        if (!string.IsNullOrEmpty(sourceUrl))
        {
            sb.AppendLine($"// Source: {sourceUrl}");
        }
        sb.AppendLine("// Do not edit this file manually.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates a standard auto-generated file header with nullable enable.
    /// </summary>
    public static void GenerateFileHeaderWithNullable(StringBuilder sb, string? sourceUrl = null)
    {
        GenerateFileHeader(sb, sourceUrl);
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
    }

    /// <summary>
    /// Converts a CLI option name to a valid C# enum name.
    /// Example: "--verbosity" -> "Verbosity", "--dry-run" -> "DryRun"
    /// </summary>
    public static string ToEnumName(string optionName, string commandPrefix)
    {
        var cleaned = optionName.TrimStart('-');
        var pascalCase = ToPascalCase(cleaned);
        return $"{commandPrefix}{pascalCase}";
    }

    /// <summary>
    /// Converts a CLI enum value to a valid C# enum member name.
    /// Example: "quiet" -> "Quiet", "dry-run" -> "DryRun", "1" -> "Value1"
    /// </summary>
    public static string ToEnumMemberName(string cliValue)
    {
        if (string.IsNullOrWhiteSpace(cliValue))
        {
            return "Unknown";
        }

        // Handle numeric values
        if (char.IsDigit(cliValue[0]))
        {
            return $"Value{cliValue}";
        }

        // Convert to PascalCase
        var pascalCase = ToPascalCase(cliValue);

        // Ensure it starts with a letter
        if (!char.IsLetter(pascalCase[0]))
        {
            pascalCase = $"Value{pascalCase}";
        }

        return pascalCase;
    }

    /// <summary>
    /// Converts a string to PascalCase.
    /// Handles kebab-case, snake_case, and space-separated words.
    /// </summary>
    public static string ToPascalCase(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
        {
            return string.Empty;
        }

        // Split on common separators
        var words = SeparatorPattern().Split(input);
        var sb = new StringBuilder();

        foreach (var word in words)
        {
            if (string.IsNullOrWhiteSpace(word))
            {
                continue;
            }

            // Capitalize first letter, lowercase the rest
            sb.Append(char.ToUpperInvariant(word[0]));
            if (word.Length > 1)
            {
                sb.Append(word[1..].ToLowerInvariant());
            }
        }

        return sb.ToString();
    }

    [GeneratedRegex(@"[-_\s]+")]
    private static partial Regex SeparatorPattern();

    /// <summary>
    /// C# reserved keywords that cannot be used as identifiers without escaping.
    /// </summary>
    private static readonly HashSet<string> CSharpKeywords = new(StringComparer.Ordinal)
    {
        "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked",
        "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else",
        "enum", "event", "explicit", "extern", "false", "finally", "fixed", "float", "for",
        "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock",
        "long", "namespace", "new", "null", "object", "operator", "out", "override", "params",
        "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed",
        "short", "sizeof", "stackalloc", "static", "string", "struct", "switch", "this",
        "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort",
        "using", "virtual", "void", "volatile", "while"
    };

    /// <summary>
    /// Escapes a C# identifier if it's a reserved keyword by prefixing with @.
    /// </summary>
    public static string EscapeIdentifier(string identifier)
    {
        if (string.IsNullOrEmpty(identifier))
        {
            return identifier;
        }

        return CSharpKeywords.Contains(identifier) ? $"@{identifier}" : identifier;
    }
}
