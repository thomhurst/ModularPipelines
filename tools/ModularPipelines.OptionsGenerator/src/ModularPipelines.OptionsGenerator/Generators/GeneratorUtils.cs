using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using ModularPipelines.OptionsGenerator.Models;

namespace ModularPipelines.OptionsGenerator.Generators;

/// <summary>
/// Shared utilities for code generators.
/// Centralizes common functionality to avoid DRY violations.
/// </summary>
public static partial class GeneratorUtils
{
    /// <summary>
    /// Escapes text for use in XML documentation comments.
    /// </summary>
    public static string EscapeXmlComment(string text)
    {
        if (string.IsNullOrEmpty(text))
        {
            return string.Empty;
        }

        return text
            .Replace("&", "&amp;")
            .Replace("<", "&lt;")
            .Replace(">", "&gt;")
            .Replace("\r\n", " ")
            .Replace("\n", " ")
            .Replace("\r", " ")
            .Trim();
    }

    /// <summary>
    /// Generates a standard auto-generated file header.
    /// </summary>
    /// <param name="sb">The StringBuilder to append to.</param>
    /// <param name="sourceUrl">Optional documentation source URL.</param>
    public static void GenerateFileHeader(StringBuilder sb, string? sourceUrl = null)
    {
        ArgumentNullException.ThrowIfNull(sb);

        sb.AppendLine("// <auto-generated>");
        sb.AppendLine($"// This file was generated by ModularPipelines.OptionsGenerator on {DateTime.UtcNow:yyyy-MM-dd}.");
        if (!string.IsNullOrEmpty(sourceUrl))
        {
            sb.AppendLine($"// Source: {sourceUrl}");
        }
        sb.AppendLine("// Do not edit this file manually.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine();
    }

    /// <summary>
    /// Generates a standard auto-generated file header with nullable enable.
    /// </summary>
    public static void GenerateFileHeaderWithNullable(StringBuilder sb, string? sourceUrl = null)
    {
        GenerateFileHeader(sb, sourceUrl);
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
    }

    /// <summary>
    /// Converts a CLI option name to a valid C# enum name.
    /// Example: "--verbosity" -> "Verbosity", "--dry-run" -> "DryRun"
    /// </summary>
    public static string ToEnumName(string optionName, string commandPrefix)
    {
        var cleaned = optionName.TrimStart('-');
        var pascalCase = ToPascalCase(cleaned);
        return $"{commandPrefix}{pascalCase}";
    }

    /// <summary>
    /// Converts a CLI enum value to a valid C# enum member name.
    /// Example: "quiet" -> "Quiet", "dry-run" -> "DryRun", "1" -> "Value1"
    /// </summary>
    public static string ToEnumMemberName(string cliValue)
    {
        if (string.IsNullOrWhiteSpace(cliValue))
        {
            return "Unknown";
        }

        // Handle numeric values
        if (char.IsDigit(cliValue[0]))
        {
            return $"Value{cliValue}";
        }

        // Convert to PascalCase
        var pascalCase = ToPascalCase(cliValue);

        // Ensure it starts with a letter
        if (!char.IsLetter(pascalCase[0]))
        {
            pascalCase = $"Value{pascalCase}";
        }

        return pascalCase;
    }

    /// <summary>
    /// Converts a string to PascalCase.
    /// Handles kebab-case, snake_case, and space-separated words.
    /// </summary>
    public static string ToPascalCase(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
        {
            return string.Empty;
        }

        // Split on common separators
        var words = SeparatorPattern().Split(input);
        var sb = new StringBuilder();

        foreach (var word in words)
        {
            if (string.IsNullOrWhiteSpace(word))
            {
                continue;
            }

            // Capitalize first letter, lowercase the rest
            sb.Append(char.ToUpperInvariant(word[0]));
            if (word.Length > 1)
            {
                sb.Append(word[1..].ToLowerInvariant());
            }
        }

        return sb.ToString();
    }

    [GeneratedRegex(@"[-_\s]+")]
    private static partial Regex SeparatorPattern();

    /// <summary>
    /// C# reserved keywords that cannot be used as identifiers without escaping.
    /// </summary>
    private static readonly HashSet<string> CSharpKeywords = new(StringComparer.Ordinal)
    {
        "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked",
        "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else",
        "enum", "event", "explicit", "extern", "false", "finally", "fixed", "float", "for",
        "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock",
        "long", "namespace", "new", "null", "object", "operator", "out", "override", "params",
        "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed",
        "short", "sizeof", "stackalloc", "static", "string", "struct", "switch", "this",
        "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort",
        "using", "virtual", "void", "volatile", "while"
    };

    /// <summary>
    /// Escapes a C# identifier if it's a reserved keyword by prefixing with @.
    /// </summary>
    public static string EscapeIdentifier(string identifier)
    {
        if (string.IsNullOrEmpty(identifier))
        {
            return identifier;
        }

        return CSharpKeywords.Contains(identifier) ? $"@{identifier}" : identifier;
    }

    /// <summary>
    /// Generates the CLI attribute string for an option definition.
    /// Used by both OptionsClassGenerator and GlobalOptionsBaseGenerator.
    /// </summary>
    /// <param name="option">The CLI option definition.</param>
    /// <returns>The attribute string (e.g., "CliFlag(\"--verbose\")" or "CliOption(\"--output\")").</returns>
    public static string GenerateCliAttributeString(CliOptionDefinition option)
    {
        if (option.IsFlag)
        {
            // Use CliFlag for boolean flags
            var parts = new List<string> { $"\"{option.SwitchName}\"" };

            if (!string.IsNullOrEmpty(option.ShortForm))
            {
                parts.Add($"ShortForm = \"{option.ShortForm}\"");
            }

            return $"CliFlag({string.Join(", ", parts)})";
        }

        // Use CliOption for value options
        var optionParts = new List<string> { $"\"{option.SwitchName}\"" };

        if (!string.IsNullOrEmpty(option.ShortForm))
        {
            optionParts.Add($"ShortForm = \"{option.ShortForm}\"");
        }

        if (option.ValueSeparator == "=")
        {
            optionParts.Add("Format = OptionFormat.EqualsSeparated");
        }
        else if (option.ValueSeparator == ":")
        {
            optionParts.Add("Format = OptionFormat.ColonSeparated");
        }
        else if (option.ValueSeparator != " " && !string.IsNullOrEmpty(option.ValueSeparator))
        {
            optionParts.Add($"CustomSeparator = \"{option.ValueSeparator}\"");
        }

        if (option.AcceptsMultipleValues)
        {
            optionParts.Add("AllowMultiple = true");
        }

        return $"CliOption({string.Join(", ", optionParts)})";
    }

    /// <summary>
    /// Generates validation attribute lines for an option with validation constraints.
    /// </summary>
    /// <param name="sb">The StringBuilder to append to.</param>
    /// <param name="constraints">The validation constraints.</param>
    /// <param name="indent">The indentation string (defaults to 4 spaces).</param>
    public static void GenerateValidationAttributes(StringBuilder sb, CliValidationConstraints constraints, string indent = "    ")
    {
        ArgumentNullException.ThrowIfNull(sb);
        ArgumentNullException.ThrowIfNull(constraints);

        if (constraints.MinValue.HasValue || constraints.MaxValue.HasValue)
        {
            var min = constraints.MinValue ?? int.MinValue;
            var max = constraints.MaxValue ?? int.MaxValue;
            sb.AppendLine($"{indent}[Range({min}, {max})]");
        }

        if (!string.IsNullOrEmpty(constraints.Pattern))
        {
            sb.AppendLine($"{indent}[RegularExpression(@\"{constraints.Pattern}\")]");
        }
    }

    /// <summary>
    /// Generates XML documentation block for a description.
    /// </summary>
    /// <param name="sb">The StringBuilder to append to.</param>
    /// <param name="description">The description text.</param>
    /// <param name="indent">The indentation string (defaults to 4 spaces).</param>
    public static void GenerateXmlDocumentation(StringBuilder sb, string? description, string indent = "    ")
    {
        ArgumentNullException.ThrowIfNull(sb);

        if (!string.IsNullOrEmpty(description))
        {
            sb.AppendLine($"{indent}/// <summary>");
            sb.AppendLine($"{indent}/// {EscapeXmlComment(description)}");
            sb.AppendLine($"{indent}/// </summary>");
        }
    }

    /// <summary>
    /// Generates a C# method name from CLI command parts.
    /// Converts command parts to PascalCase method name.
    /// E.g., ["container", "create"] -> "ContainerCreate", ["build-server"] -> "BuildServer"
    /// </summary>
    /// <param name="commandParts">The command parts array.</param>
    /// <returns>The method name in PascalCase.</returns>
    public static string GenerateMethodNameFromCommandParts(string[] commandParts)
    {
        return string.Join("", commandParts
            .SelectMany(p => p.Split('-', StringSplitOptions.RemoveEmptyEntries))
            .Select(p => char.ToUpperInvariant(p[0]) + (p.Length > 1 ? p[1..].ToLowerInvariant() : "")));
    }

    /// <summary>
    /// Generates a C# method name from the last part of a CLI command.
    /// Used for sub-domain commands where the method name is derived from the last segment.
    /// E.g., ["network", "create"] uses "create" -> "Create"
    /// </summary>
    /// <param name="command">The CLI command definition.</param>
    /// <returns>The method name in PascalCase, or "Execute" if no command parts.</returns>
    public static string GenerateMethodNameFromLastCommandPart(CliCommandDefinition command)
    {
        if (command.CommandParts.Length == 0)
        {
            return "Execute";
        }

        var lastPart = command.CommandParts[^1];
        var parts = lastPart.Split('-', StringSplitOptions.RemoveEmptyEntries);
        return string.Join("", parts.Select(p =>
            char.ToUpperInvariant(p[0]) + (p.Length > 1 ? p[1..].ToLowerInvariant() : "")));
    }
}
