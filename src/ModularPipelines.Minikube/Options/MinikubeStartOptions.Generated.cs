// <auto-generated>
// This file was generated by ModularPipelines.OptionsGenerator.
// Do not edit this file manually.
// </auto-generated>

using System.CodeDom.Compiler;
using System.Diagnostics.CodeAnalysis;
using ModularPipelines.Attributes;
using ModularPipelines.Minikube.Options;
using ModularPipelines.Minikube.Enums;

namespace ModularPipelines.Minikube.Options;

/// <summary>
/// Starts a local Kubernetes cluster
/// </summary>
[GeneratedCode("ModularPipelines.OptionsGenerator", "")]
[ExcludeFromCodeCoverage]
[CliSubCommand("start")]
public record MinikubeStartOptions : MinikubeOptions
{
    /// <summary>
    /// Enable one or more addons, in a comma-separated format. See `minikube addons list` for a list of valid addon names.
    /// </summary>
    [CliOption("--addons", Format = OptionFormat.EqualsSeparated)]
    public string? Addons { get; set; }

    /// <summary>
    /// A set of apiserver IP Addresses which are used in the generated certificate for kubernetes.  This can be used if you want to make the apiserver available from outside the machine
    /// </summary>
    [CliOption("--apiserver-ips", Format = OptionFormat.EqualsSeparated)]
    public string? ApiserverIps { get; set; }

    /// <summary>
    /// The authoritative apiserver hostname for apiserver certificates and connectivity. This can be used if you want to make the apiserver available from outside the machine
    /// </summary>
    [CliOption("--apiserver-name", Format = OptionFormat.EqualsSeparated)]
    public string? ApiserverName { get; set; }

    /// <summary>
    /// A set of apiserver names which are used in the generated certificate for kubernetes.  This can be used if you want to make the apiserver available from outside the machine
    /// </summary>
    [CliOption("--apiserver-names", Format = OptionFormat.EqualsSeparated)]
    public string? ApiserverNames { get; set; }

    /// <summary>
    /// The apiserver listening port
    /// </summary>
    [CliOption("--apiserver-port", Format = OptionFormat.EqualsSeparated)]
    public string? ApiserverPort { get; set; }

    /// <summary>
    /// Duration of inactivity before the minikube VM is paused (default 1m0s)
    /// </summary>
    [CliOption("--auto-pause-interval", Format = OptionFormat.EqualsSeparated)]
    public string? AutoPauseInterval { get; set; }

    /// <summary>
    /// If set, automatically updates drivers to the latest version. Defaults to true.
    /// </summary>
    [CliOption("--auto-update-drivers", Format = OptionFormat.EqualsSeparated)]
    public string? AutoUpdateDrivers { get; set; }

    /// <summary>
    /// The base image to use for docker/podman drivers. Intended for local development.
    /// </summary>
    [CliOption("--base-image", Format = OptionFormat.EqualsSeparated)]
    public string? BaseImage { get; set; }

    /// <summary>
    /// Location to fetch kubectl, kubelet, &amp; kubeadm binaries from.
    /// </summary>
    [CliOption("--binary-mirror", Format = OptionFormat.EqualsSeparated)]
    public string? BinaryMirror { get; set; }

    /// <summary>
    /// If true, cache docker images for the current bootstrapper and load them into the machine. Always false with --driver=none.
    /// </summary>
    [CliOption("--cache-images", Format = OptionFormat.EqualsSeparated)]
    public string? CacheImages { get; set; }

    /// <summary>
    /// Duration until minikube certificate expiration, defaults to three years (26280h).
    /// </summary>
    [CliOption("--cert-expiration", Format = OptionFormat.EqualsSeparated)]
    public string? CertExpiration { get; set; }

    /// <summary>
    /// CNI plug-in to use. Valid options: auto, bridge, calico, cilium, flannel, kindnet, or path to a CNI manifest (default: auto)
    /// </summary>
    [CliOption("--cni", Format = OptionFormat.EqualsSeparated)]
    public string? Cni { get; set; }

    /// <summary>
    /// The container runtime to be used. Valid options: docker, cri-o, containerd (default: auto)
    /// </summary>
    [CliOption("--container-runtime", ShortForm = "-c", Format = OptionFormat.EqualsSeparated)]
    public string? ContainerRuntime { get; set; }

    /// <summary>
    /// Number of CPUs allocated to Kubernetes. Use "max" to use the maximum number of CPUs. Use "no-limit" to not specify a limit (Docker/Podman only)
    /// </summary>
    [CliOption("--cpus", Format = OptionFormat.EqualsSeparated)]
    public string? Cpus { get; set; }

    /// <summary>
    /// The cri socket path to be used.
    /// </summary>
    [CliOption("--cri-socket", Format = OptionFormat.EqualsSeparated)]
    public string? CriSocket { get; set; }

    /// <summary>
    /// If set, delete the current cluster if start fails and try again. Defaults to false.
    /// </summary>
    [CliOption("--delete-on-failure", Format = OptionFormat.EqualsSeparated)]
    public string? DeleteOnFailure { get; set; }

    /// <summary>
    /// If set, disable CoreDNS verbose logging. Defaults to false.
    /// </summary>
    [CliOption("--disable-coredns-log", Format = OptionFormat.EqualsSeparated)]
    public string? DisableCorednsLog { get; set; }

    /// <summary>
    /// Disables the filesystem mounts provided by the hypervisors
    /// </summary>
    [CliOption("--disable-driver-mounts", Format = OptionFormat.EqualsSeparated)]
    public string? DisableDriverMounts { get; set; }

    /// <summary>
    /// If set, disables metrics reporting (CPU and memory usage), this can improve CPU usage. Defaults to false.
    /// </summary>
    [CliOption("--disable-metrics", Format = OptionFormat.EqualsSeparated)]
    public string? DisableMetrics { get; set; }

    /// <summary>
    /// If set, disables optimizations that are set for local Kubernetes. Including decreasing CoreDNS replicas from 2 to 1. Defaults to false.
    /// </summary>
    [CliOption("--disable-optimizations", Format = OptionFormat.EqualsSeparated)]
    public string? DisableOptimizations { get; set; }

    /// <summary>
    /// Disk size allocated to the minikube VM (format: &lt;number&gt;[&lt;unit&gt;], where unit = b, k, m or g).
    /// </summary>
    [CliOption("--disk-size", Format = OptionFormat.EqualsSeparated)]
    public string? DiskSize { get; set; }

    /// <summary>
    /// The cluster dns domain name used in the Kubernetes cluster
    /// </summary>
    [CliOption("--dns-domain", Format = OptionFormat.EqualsSeparated)]
    public string? DnsDomain { get; set; }

    /// <summary>
    /// Enable proxy for NAT DNS requests (virtualbox driver only)
    /// </summary>
    [CliOption("--dns-proxy", Format = OptionFormat.EqualsSeparated)]
    public string? DnsProxy { get; set; }

    /// <summary>
    /// Environment variables to pass to the Docker daemon. (format: key=value)
    /// </summary>
    [CliOption("--docker-env", Format = OptionFormat.EqualsSeparated)]
    public string? DockerEnv { get; set; }

    /// <summary>
    /// Specify arbitrary flags to pass to the Docker daemon. (format: key=value)
    /// </summary>
    [CliOption("--docker-opt", Format = OptionFormat.EqualsSeparated)]
    public string? DockerOpt { get; set; }

    /// <summary>
    /// If true, only download and cache files for later use - don't install or start anything.
    /// </summary>
    [CliOption("--download-only", Format = OptionFormat.EqualsSeparated)]
    public string? DownloadOnly { get; set; }

    /// <summary>
    /// Driver is one of: virtualbox, kvm2, qemu2, qemu, vmware, none, docker, podman, ssh (defaults to auto-detect)
    /// </summary>
    [CliOption("--driver", ShortForm = "-d", Format = OptionFormat.EqualsSeparated)]
    public MinikubeStartDriver? Driver { get; set; }

    /// <summary>
    /// dry-run mode. Validates configuration, but does not mutate system state
    /// </summary>
    [CliOption("--dry-run", Format = OptionFormat.EqualsSeparated)]
    public string? DryRun { get; set; }

    /// <summary>
    /// if true, will embed the certs in kubeconfig.
    /// </summary>
    [CliOption("--embed-certs", Format = OptionFormat.EqualsSeparated)]
    public string? EmbedCerts { get; set; }

    /// <summary>
    /// Number of extra disks created and attached to the minikube VM (currently only implemented for hyperkit, kvm2, qemu2, vfkit, and krunkit drivers)
    /// </summary>
    [CliOption("--extra-disks", Format = OptionFormat.EqualsSeparated)]
    public string? ExtraDisks { get; set; }

    /// <summary>
    /// A set of key=value pairs that describe feature gates for alpha/experimental features.
    /// </summary>
    [CliOption("--feature-gates", Format = OptionFormat.EqualsSeparated)]
    public string? FeatureGates { get; set; }

    /// <summary>
    /// Force minikube to perform possibly dangerous operations
    /// </summary>
    [CliOption("--force", Format = OptionFormat.EqualsSeparated)]
    public string? Force { get; set; }

    /// <summary>
    /// If set, force the container runtime to use systemd as cgroup manager. Defaults to false.
    /// </summary>
    [CliOption("--force-systemd", Format = OptionFormat.EqualsSeparated)]
    public string? ForceSystemd { get; set; }

    /// <summary>
    /// Allow pods to use your GPUs. Options include: [all,nvidia,amd] (Docker driver with Docker container-runtime only)
    /// </summary>
    [CliOption("--gpus", ShortForm = "-g", Format = OptionFormat.EqualsSeparated)]
    public string? Gpus { get; set; }

    /// <summary>
    /// Create Highly Available Multi-Control Plane Cluster with a minimum of three control-plane nodes that will also be marked for work.
    /// </summary>
    [CliOption("--ha", Format = OptionFormat.EqualsSeparated)]
    public string? Ha { get; set; }

    /// <summary>
    /// Enable host resolver for NAT DNS requests (virtualbox driver only)
    /// </summary>
    [CliOption("--host-dns-resolver", Format = OptionFormat.EqualsSeparated)]
    public string? HostDnsResolver { get; set; }

    /// <summary>
    /// The CIDR to be used for the minikube VM (virtualbox driver only)
    /// </summary>
    [CliOption("--host-only-cidr", Format = OptionFormat.EqualsSeparated)]
    public string? HostOnlyCidr { get; set; }

    /// <summary>
    /// NIC Type used for host only network. One of Am79C970A, Am79C973, 82540EM, 82543GC, 82545EM, or virtio (virtualbox driver only)
    /// </summary>
    [CliOption("--host-only-nic-type", Format = OptionFormat.EqualsSeparated)]
    public MinikubeStartHostOnlyNicType? HostOnlyNicType { get; set; }

    /// <summary>
    /// Location of the VPNKit socket used for networking. If empty, disables Hyperkit VPNKitSock, if 'auto' uses Docker for Mac VPNKit connection, otherwise uses the specified VSock (hyperkit driver only)
    /// </summary>
    [CliOption("--hyperkit-vpnkit-sock", Format = OptionFormat.EqualsSeparated)]
    public string? HyperkitVpnkitSock { get; set; }

    /// <summary>
    /// List of guest VSock ports that should be exposed as sockets on the host (hyperkit driver only)
    /// </summary>
    [CliOption("--hyperkit-vsock-ports", Format = OptionFormat.EqualsSeparated)]
    public string? HyperkitVsockPorts { get; set; }

    /// <summary>
    /// External Adapter on which external switch will be created if no external switch is found. (hyperv driver only)
    /// </summary>
    [CliOption("--hyperv-external-adapter", Format = OptionFormat.EqualsSeparated)]
    public string? HypervExternalAdapter { get; set; }

    /// <summary>
    /// Whether to use external switch over Default Switch if virtual switch not explicitly specified. (hyperv driver only)
    /// </summary>
    [CliOption("--hyperv-use-external-switch", Format = OptionFormat.EqualsSeparated)]
    public string? HypervUseExternalSwitch { get; set; }

    /// <summary>
    /// The hyperv virtual switch name. Defaults to first found. (hyperv driver only)
    /// </summary>
    [CliOption("--hyperv-virtual-switch", Format = OptionFormat.EqualsSeparated)]
    public string? HypervVirtualSwitch { get; set; }

    /// <summary>
    /// Country code of the image mirror to be used. Leave empty to use the global one. For Chinese mainland users, set it to cn.
    /// </summary>
    [CliOption("--image-mirror-country", Format = OptionFormat.EqualsSeparated)]
    public string? ImageMirrorCountry { get; set; }

    /// <summary>
    /// Alternative image repository to pull docker images from. This can be used when you have limited access to gcr.io. Set it to "auto" to let minikube decide one for you. For Chinese mainland users, you may use local gcr.io mirrors such as registry.cn-hangzhou.aliyuncs.com/google_containers
    /// </summary>
    [CliOption("--image-repository", Format = OptionFormat.EqualsSeparated)]
    public string? ImageRepository { get; set; }

    /// <summary>
    /// Insecure Docker registries to pass to the Docker daemon.  The default service CIDR range will automatically be added.
    /// </summary>
    [CliOption("--insecure-registry", Format = OptionFormat.EqualsSeparated)]
    public string? InsecureRegistry { get; set; }

    /// <summary>
    /// If set, install addons. Defaults to true.
    /// </summary>
    [CliOption("--install-addons", Format = OptionFormat.EqualsSeparated)]
    public string? InstallAddons { get; set; }

    /// <summary>
    /// Allow user prompts for more information
    /// </summary>
    [CliOption("--interactive", Format = OptionFormat.EqualsSeparated)]
    public string? Interactive { get; set; }

    /// <summary>
    /// Locations to fetch the minikube ISO from.
    /// </summary>
    [CliOption("--iso-url", Format = OptionFormat.EqualsSeparated)]
    public string? IsoUrl { get; set; }

    /// <summary>
    /// This will keep the existing kubectl context and will create a minikube context.
    /// </summary>
    [CliOption("--keep-context", Format = OptionFormat.EqualsSeparated)]
    public string? KeepContext { get; set; }

    /// <summary>
    /// The Kubernetes version that the minikube VM will use (ex: v1.2.3, 'stable' for v1.35.1, 'latest' for v1.35.1). Defaults to 'stable'.
    /// </summary>
    [CliOption("--kubernetes-version", Format = OptionFormat.EqualsSeparated)]
    public string? KubernetesVersion { get; set; }

    /// <summary>
    /// Enable experimental NVIDIA GPU support in minikube
    /// </summary>
    [CliOption("--kvm-gpu", Format = OptionFormat.EqualsSeparated)]
    public string? KvmGpu { get; set; }

    /// <summary>
    /// Hide the hypervisor signature from the guest in minikube (kvm2 driver only)
    /// </summary>
    [CliOption("--kvm-hidden", Format = OptionFormat.EqualsSeparated)]
    public string? KvmHidden { get; set; }

    /// <summary>
    /// The KVM default network name. (kvm2 driver only)
    /// </summary>
    [CliOption("--kvm-network", Format = OptionFormat.EqualsSeparated)]
    public string? KvmNetwork { get; set; }

    /// <summary>
    /// Simulate numa node count in minikube, supported numa node count range is 1-8 (kvm2 driver only)
    /// </summary>
    [CliOption("--kvm-numa-count", Format = OptionFormat.EqualsSeparated)]
    public string? KvmNumaCount { get; set; }

    /// <summary>
    /// The KVM QEMU connection URI. (kvm2 driver only)
    /// </summary>
    [CliOption("--kvm-qemu-uri", Format = OptionFormat.EqualsSeparated)]
    public string? KvmQemuUri { get; set; }

    /// <summary>
    /// IP Address to use to expose ports (docker and podman driver only)
    /// </summary>
    [CliOption("--listen-address", Format = OptionFormat.EqualsSeparated)]
    public string? ListenAddress { get; set; }

    /// <summary>
    /// Amount of RAM to allocate to Kubernetes (format: &lt;number&gt;[&lt;unit&gt;], where unit = b, k, m or g). Use "max" to use the maximum amount of memory. Use "no-limit" to not specify a limit (Docker/Podman only)
    /// </summary>
    [CliOption("--memory", ShortForm = "-m", Format = OptionFormat.EqualsSeparated)]
    public string? Memory { get; set; }

    /// <summary>
    /// Kept for backward compatibility, value is ignored.
    /// </summary>
    [CliOption("--mount", Format = OptionFormat.EqualsSeparated)]
    public string? Mount { get; set; }

    /// <summary>
    /// Specify the 9p version that the mount should use
    /// </summary>
    [CliOption("--mount-9p-version", Format = OptionFormat.EqualsSeparated)]
    public string? Mount_9pVersion { get; set; }

    /// <summary>
    /// Default group id used for the mount
    /// </summary>
    [CliOption("--mount-gid", Format = OptionFormat.EqualsSeparated)]
    public string? MountGid { get; set; }

    /// <summary>
    /// Specify the ip that the mount should be setup on
    /// </summary>
    [CliOption("--mount-ip", Format = OptionFormat.EqualsSeparated)]
    public string? MountIp { get; set; }

    /// <summary>
    /// The number of bytes to use for 9p packet payload
    /// </summary>
    [CliOption("--mount-msize", Format = OptionFormat.EqualsSeparated)]
    public string? MountMsize { get; set; }

    /// <summary>
    /// Additional mount options, such as cache=fscache
    /// </summary>
    [CliOption("--mount-options", Format = OptionFormat.EqualsSeparated)]
    public string? MountOptions { get; set; }

    /// <summary>
    /// Specify the port that the mount should be setup on, where 0 means any free port.
    /// </summary>
    [CliOption("--mount-port", Format = OptionFormat.EqualsSeparated)]
    public string? MountPort { get; set; }

    /// <summary>
    /// Directory to mount in the guest using format '/host-path:/guest-path'.
    /// </summary>
    [CliOption("--mount-string", Format = OptionFormat.EqualsSeparated)]
    public string? MountString { get; set; }

    /// <summary>
    /// Specify the mount filesystem type (supported types: 9p)
    /// </summary>
    [CliOption("--mount-type", Format = OptionFormat.EqualsSeparated)]
    public string? MountType { get; set; }

    /// <summary>
    /// Default user id used for the mount
    /// </summary>
    [CliOption("--mount-uid", Format = OptionFormat.EqualsSeparated)]
    public string? MountUid { get; set; }

    /// <summary>
    /// The named space to activate after start
    /// </summary>
    [CliOption("--namespace", Format = OptionFormat.EqualsSeparated)]
    public string? Namespace { get; set; }

    /// <summary>
    /// NIC Type used for nat network. One of Am79C970A, Am79C973, 82540EM, 82543GC, 82545EM, or virtio (virtualbox driver only)
    /// </summary>
    [CliOption("--nat-nic-type", Format = OptionFormat.EqualsSeparated)]
    public MinikubeStartNatNicType? NatNicType { get; set; }

    /// <summary>
    /// Use native Golang SSH client (default true). Set to 'false' to use the command line 'ssh' command when accessing the docker machine. Useful for the machine drivers when they will not start with 'Waiting for SSH'.
    /// </summary>
    [CliOption("--native-ssh", Format = OptionFormat.EqualsSeparated)]
    public string? NativeSsh { get; set; }

    /// <summary>
    /// network to run minikube with. Used by docker/podman, qemu, kvm, and vfkit drivers. If left empty, minikube will create a new network.
    /// </summary>
    [CliOption("--network", Format = OptionFormat.EqualsSeparated)]
    public string? Network { get; set; }

    /// <summary>
    /// Local folders to share with Guest via NFS mounts (hyperkit driver only)
    /// </summary>
    [CliOption("--nfs-share", Format = OptionFormat.EqualsSeparated)]
    public string? NfsShare { get; set; }

    /// <summary>
    /// Where to root the NFS Shares, defaults to /nfsshares (hyperkit driver only)
    /// </summary>
    [CliOption("--nfs-shares-root", Format = OptionFormat.EqualsSeparated)]
    public string? NfsSharesRoot { get; set; }

    /// <summary>
    /// If set, minikube VM/container will start without starting or configuring Kubernetes. (only works on new clusters)
    /// </summary>
    [CliOption("--no-kubernetes", Format = OptionFormat.EqualsSeparated)]
    public string? NoKubernetes { get; set; }

    /// <summary>
    /// Disable checking for the availability of hardware virtualization before the vm is started (virtualbox driver only)
    /// </summary>
    [CliOption("--no-vtx-check", Format = OptionFormat.EqualsSeparated)]
    public string? NoVtxCheck { get; set; }

    /// <summary>
    /// The total number of nodes to spin up. Defaults to 1.
    /// </summary>
    [CliOption("--nodes", ShortForm = "-n", Format = OptionFormat.EqualsSeparated)]
    public string? Nodes { get; set; }

    /// <summary>
    /// Format to print stdout in. Options include: [text,json]
    /// </summary>
    [CliOption("--output", ShortForm = "-o", Format = OptionFormat.EqualsSeparated)]
    public string? Output { get; set; }

    /// <summary>
    /// List of ports that should be exposed (docker and podman driver only)
    /// </summary>
    [CliOption("--ports", Format = OptionFormat.EqualsSeparated)]
    public string? Ports { get; set; }

    /// <summary>
    /// If set, download tarball of preloaded images if available to improve start time. Defaults to true.
    /// </summary>
    [CliOption("--preload", Format = OptionFormat.EqualsSeparated)]
    public string? Preload { get; set; }

    /// <summary>
    /// Which source to download the preload from (valid options: gcs, github, auto). Defaults to auto (try both).
    /// </summary>
    [CliOption("--preload-source", Format = OptionFormat.EqualsSeparated)]
    public string? PreloadSource { get; set; }

    /// <summary>
    /// Path to the qemu firmware file. Defaults: For Linux, the default firmware location. For macOS, the brew installation location. For Windows, C:\Program Files\qemu\share
    /// </summary>
    [CliOption("--qemu-firmware-path", Format = OptionFormat.EqualsSeparated)]
    public string? QemuFirmwarePath { get; set; }

    /// <summary>
    /// Registry mirrors to pass to the Docker daemon
    /// </summary>
    [CliOption("--registry-mirror", Format = OptionFormat.EqualsSeparated)]
    public string? RegistryMirror { get; set; }

    /// <summary>
    /// Enable Rosetta to support apps built for Intel processor on a Mac with Apple silicon (vfkit driver only)
    /// </summary>
    [CliOption("--rosetta", Format = OptionFormat.EqualsSeparated)]
    public string? Rosetta { get; set; }

    /// <summary>
    /// The CIDR to be used for service cluster IPs.
    /// </summary>
    [CliOption("--service-cluster-ip-range", Format = OptionFormat.EqualsSeparated)]
    public string? ServiceClusterIpRange { get; set; }

    /// <summary>
    /// Path to the socket vmnet client binary (QEMU driver only)
    /// </summary>
    [CliOption("--socket-vmnet-client-path", Format = OptionFormat.EqualsSeparated)]
    public string? SocketVmnetClientPath { get; set; }

    /// <summary>
    /// Path to socket vmnet binary (QEMU driver only)
    /// </summary>
    [CliOption("--socket-vmnet-path", Format = OptionFormat.EqualsSeparated)]
    public string? SocketVmnetPath { get; set; }

    /// <summary>
    /// IP address (ssh driver only)
    /// </summary>
    [CliOption("--ssh-ip-address", Format = OptionFormat.EqualsSeparated)]
    public string? SshIpAddress { get; set; }

    /// <summary>
    /// SSH key (ssh driver only)
    /// </summary>
    [CliOption("--ssh-key", Format = OptionFormat.EqualsSeparated)]
    public string? SshKey { get; set; }

    /// <summary>
    /// SSH port (ssh driver only)
    /// </summary>
    [CliOption("--ssh-port", Format = OptionFormat.EqualsSeparated)]
    public string? SshPort { get; set; }

    /// <summary>
    /// SSH user (ssh driver only)
    /// </summary>
    [CliOption("--ssh-user", Format = OptionFormat.EqualsSeparated)]
    public string? SshUser { get; set; }

    /// <summary>
    /// Set a static IP for the minikube cluster, the IP must be: private, IPv4, and the last octet must be between 2 and 254, for example 192.168.200.200 (Docker and Podman drivers only)
    /// </summary>
    [CliOption("--static-ip", Format = OptionFormat.EqualsSeparated)]
    public string? StaticIp { get; set; }

    /// <summary>
    /// Subnet to be used on kic cluster. If left empty, minikube will choose subnet address, beginning from 192.168.49.0. (docker and podman driver only)
    /// </summary>
    [CliOption("--subnet", Format = OptionFormat.EqualsSeparated)]
    public string? Subnet { get; set; }

    /// <summary>
    /// Send trace events. Options include: [gcp]
    /// </summary>
    [CliOption("--trace", Format = OptionFormat.EqualsSeparated)]
    public string? Trace { get; set; }

    /// <summary>
    /// Provide VM UUID to restore MAC address (hyperkit driver only)
    /// </summary>
    [CliOption("--uuid", Format = OptionFormat.EqualsSeparated)]
    public string? Uuid { get; set; }

    /// <summary>
    /// Filter to use only VM Drivers
    /// </summary>
    [CliOption("--vm", Format = OptionFormat.EqualsSeparated)]
    public string? Vm { get; set; }

    /// <summary>
    /// comma separated list of Kubernetes components to verify and wait for after starting a cluster. defaults to "apiserver,system_pods", available options: "apiserver,system_pods,default_sa,apps_running,node_ready,kubelet,extra" . other acceptable values are 'all' or 'none', 'true' and 'false'
    /// </summary>
    [CliOption("--wait", Format = OptionFormat.EqualsSeparated)]
    public string? Wait { get; set; }

    /// <summary>
    /// max time to wait per Kubernetes or host to be healthy.
    /// </summary>
    [CliOption("--wait-timeout", Format = OptionFormat.EqualsSeparated)]
    public string? WaitTimeout { get; set; }

}
