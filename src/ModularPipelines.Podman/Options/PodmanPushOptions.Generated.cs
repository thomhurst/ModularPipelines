// <auto-generated>
// This file was generated by ModularPipelines.OptionsGenerator.
// Do not edit this file manually.
// </auto-generated>

#nullable enable

using System.CodeDom.Compiler;
using System.Diagnostics.CodeAnalysis;
using ModularPipelines.Attributes;
using ModularPipelines.Podman.Options;

namespace ModularPipelines.Podman.Options;

/// <summary>
/// Push an image to a specified destination
/// </summary>
[GeneratedCode("ModularPipelines.OptionsGenerator", "2.42.227-alpha.0.981+55c59948e83059a5184db05c992047e177e72c4b")]
[ExcludeFromCodeCoverage]
[CliSubCommand("push")]
public record PodmanPushOptions : PodmanOptions
{
    /// <summary>
    /// Path of the authentication file. Use REGISTRY_AUTH_FILE environment variable to override
    /// </summary>
    [CliOption("--authfile", Format = OptionFormat.EqualsSeparated)]
    public string? Authfile { get; set; }

    /// <summary>
    /// Path to a directory containing TLS certificates and keys
    /// </summary>
    [CliOption("--cert-dir", Format = OptionFormat.EqualsSeparated)]
    public string? CertDir { get; set; }

    /// <summary>
    /// Compress tarball image layers when pushing to a directory using the 'dir' transport. (default is same compression type as source)
    /// </summary>
    [CliFlag("--compress")]
    public bool? Compress { get; set; }

    /// <summary>
    /// compression format to use (default "gzip")
    /// </summary>
    [CliOption("--compression-format", Format = OptionFormat.EqualsSeparated)]
    public string? CompressionFormat { get; set; }

    /// <summary>
    /// compression level to use
    /// </summary>
    [CliOption("--compression-level", Format = OptionFormat.EqualsSeparated)]
    public int? CompressionLevel { get; set; }

    /// <summary>
    /// Credentials (USERNAME:PASSWORD) to use for authenticating to a registry
    /// </summary>
    [CliOption("--creds", Format = OptionFormat.EqualsSeparated)]
    public string? Creds { get; set; }

    /// <summary>
    /// Write the digest of the pushed image to the specified file
    /// </summary>
    [CliOption("--digestfile", Format = OptionFormat.EqualsSeparated)]
    public string? Digestfile { get; set; }

    /// <summary>
    /// This is a Docker specific option and is a NOOP
    /// </summary>
    [CliFlag("--disable-content-trust")]
    public bool? DisableContentTrust { get; set; }

    /// <summary>
    /// Layers to encrypt, 0-indexed layer indices with support for negative indexing (e.g. 0 is the first layer, -1 is the last layer). If not defined, will encrypt all layers if encryption-key flag is specified
    /// </summary>
    [CliOption("--encrypt-layer", Format = OptionFormat.EqualsSeparated)]
    public string? EncryptLayer { get; set; }

    /// <summary>
    /// Key with the encryption protocol to use to encrypt the image (e.g. jwe:/path/to/key.pem)
    /// </summary>
    [CliOption("--encryption-key", Format = OptionFormat.EqualsSeparated, AllowMultiple = true)]
    public IEnumerable<string>? EncryptionKey { get; set; }

    /// <summary>
    /// Use the specified compression algorithm even if the destination contains a differently-compressed variant already
    /// </summary>
    [CliFlag("--force-compression")]
    public bool? ForceCompression { get; set; }

    /// <summary>
    /// Manifest type (oci, v2s2, or v2s1) to use in the destination (default is manifest type of source, with fallbacks)
    /// </summary>
    [CliOption("--format", ShortForm = "-f", Format = OptionFormat.EqualsSeparated)]
    public string? Format { get; set; }

    /// <summary>
    /// Suppress output information when pushing images
    /// </summary>
    [CliFlag("--quiet", ShortForm = "-q")]
    public bool? Quiet { get; set; }

    /// <summary>
    /// Discard any pre-existing signatures in the image
    /// </summary>
    [CliFlag("--remove-signatures")]
    public bool? RemoveSignatures { get; set; }

    /// <summary>
    /// Add a signature at the destination using the specified key
    /// </summary>
    [CliOption("--sign-by", Format = OptionFormat.EqualsSeparated)]
    public string? SignBy { get; set; }

    /// <summary>
    /// Sign the image using a sigstore parameter file at PATH
    /// </summary>
    [CliOption("--sign-by-sigstore", Format = OptionFormat.EqualsSeparated)]
    public string? SignBySigstore { get; set; }

    /// <summary>
    /// Sign the image using a sigstore private key at PATH
    /// </summary>
    [SecretValue]
    [CliOption("--sign-by-sigstore-private-key", Format = OptionFormat.EqualsSeparated)]
    public string? SignBySigstorePrivateKey { get; set; }

    /// <summary>
    /// Read a passphrase for signing an image from PATH
    /// </summary>
    [CliOption("--sign-passphrase-file", Format = OptionFormat.EqualsSeparated)]
    public string? SignPassphraseFile { get; set; }

    /// <summary>
    /// Require HTTPS and verify certificates when contacting registries (default true)
    /// </summary>
    [CliFlag("--tls-verify")]
    public bool? TlsVerify { get; set; }

    [CliArgument(0, Placement = ArgumentPlacement.BeforeOptions)]
    public string? Destination { get; set; }

}
