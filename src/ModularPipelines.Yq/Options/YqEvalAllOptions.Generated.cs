// <auto-generated>
// This file was generated by ModularPipelines.OptionsGenerator.
// Do not edit this file manually.
// </auto-generated>

using System.CodeDom.Compiler;
using System.Diagnostics.CodeAnalysis;
using ModularPipelines.Attributes;
using ModularPipelines.Yq.Options;
using ModularPipelines.Yq.Enums;

namespace ModularPipelines.Yq.Options;

/// <summary>
/// yq is a portable command-line data file processor (https://github.com/mikefarah/yq/)
/// </summary>
[GeneratedCode("ModularPipelines.OptionsGenerator", "")]
[ExcludeFromCodeCoverage]
[CliSubCommand("eval-all")]
public record YqEvalAllOptions : YqOptions
{
    /// <summary>
    /// help for eval-all
    /// </summary>
    [CliFlag("--help", ShortForm = "-h")]
    public bool? Help { get; set; }

    /// <summary>
    /// force print with colors
    /// </summary>
    [CliFlag("--colors", ShortForm = "-C")]
    public bool? Colors { get; set; }

    /// <summary>
    /// parse CSV YAML/JSON values (default true)
    /// </summary>
    [CliFlag("--csv-auto-parse")]
    public bool? CsvAutoParse { get; set; }

    /// <summary>
    /// CSV Separator character (default ,)
    /// </summary>
    [CliOption("--csv-separator", Format = OptionFormat.EqualsSeparated)]
    public string? CsvSeparator { get; set; }

    /// <summary>
    /// debug node info
    /// </summary>
    [CliFlag("--debug-node-info")]
    public bool? DebugNodeInfo { get; set; }

    /// <summary>
    /// set exit status if there are no matches or null or false is returned
    /// </summary>
    [CliFlag("--exit-status", ShortForm = "-e")]
    public bool? ExitStatus { get; set; }

    /// <summary>
    /// forcibly set the expression argument. Useful when yq argument detection thinks your expression is a file.
    /// </summary>
    [CliOption("--expression", Format = OptionFormat.EqualsSeparated)]
    public string? Expression { get; set; }

    /// <summary>
    /// Load expression from specified file.
    /// </summary>
    [CliOption("--from-file", Format = OptionFormat.EqualsSeparated)]
    public string? FromFile { get; set; }

    /// <summary>
    /// (extract|process) first input as yaml front-matter. Extract will pull out the yaml content, process will run the expression against the yaml content, leaving the remaining data intact
    /// </summary>
    [CliOption("--front-matter", ShortForm = "-f", Format = OptionFormat.EqualsSeparated)]
    public YqEvalAllFrontMatter? FrontMatter { get; set; }

    /// <summary>
    /// Slurp any header comments and separators before processing expression. (default true)
    /// </summary>
    [CliFlag("--header-preprocess")]
    public bool? HeaderPreprocess { get; set; }

    /// <summary>
    /// sets indent level for output (default 2)
    /// </summary>
    [CliOption("--indent", ShortForm = "-I", Format = OptionFormat.EqualsSeparated)]
    public int? Indent { get; set; }

    /// <summary>
    /// update the file in place of first file given.
    /// </summary>
    [CliFlag("--inplace", ShortForm = "-i")]
    public bool? Inplace { get; set; }

    /// <summary>
    /// [auto|a|yaml|y|kyaml|ky|json|j|props|p|csv|c|tsv|t|xml|x|base64|uri|toml|hcl|h|lua|l|ini|i] parse format for input. (default "auto")
    /// </summary>
    [CliOption("--input-format", ShortForm = "-p", Format = OptionFormat.EqualsSeparated)]
    public string? InputFormat { get; set; }

    /// <summary>
    /// output keys as top-level global variables
    /// </summary>
    [CliFlag("--lua-globals")]
    public bool? LuaGlobals { get; set; }

    /// <summary>
    /// prefix (default "return ")
    /// </summary>
    [CliOption("--lua-prefix", Format = OptionFormat.EqualsSeparated)]
    public string? LuaPrefix { get; set; }

    /// <summary>
    /// suffix (default ";\n")
    /// </summary>
    [CliOption("--lua-suffix", Format = OptionFormat.EqualsSeparated)]
    public string? LuaSuffix { get; set; }

    /// <summary>
    /// output unquoted string keys (e.g. {foo="bar"})
    /// </summary>
    [CliFlag("--lua-unquoted")]
    public bool? LuaUnquoted { get; set; }

    /// <summary>
    /// force print with no colors
    /// </summary>
    [CliFlag("--no-colors", ShortForm = "-M")]
    public bool? NoColors { get; set; }

    /// <summary>
    /// Don't print document separators (---)
    /// </summary>
    [CliFlag("--no-doc", ShortForm = "-N")]
    public bool? NoDoc { get; set; }

    /// <summary>
    /// Use NUL char to separate values. If unwrap scalar is also set, fail if unwrapped scalar contains NUL char.
    /// </summary>
    [CliFlag("--nul-output", ShortForm = "-0")]
    public bool? NulOutput { get; set; }

    /// <summary>
    /// Don't read input, simply evaluate the expression given. Useful for creating docs from scratch.
    /// </summary>
    [CliFlag("--null-input", ShortForm = "-n")]
    public bool? NullInput { get; set; }

    /// <summary>
    /// [auto|a|yaml|y|kyaml|ky|json|j|props|p|csv|c|tsv|t|xml|x|base64|uri|toml|hcl|h|shell|s|lua|l|ini|i] output format type. (default "auto")
    /// </summary>
    [CliOption("--output-format", ShortForm = "-o", Format = OptionFormat.EqualsSeparated)]
    public string? OutputFormat { get; set; }

    /// <summary>
    /// pretty print, shorthand for '... style = ""'
    /// </summary>
    [CliFlag("--prettyPrint", ShortForm = "-P")]
    public bool? Prettyprint { get; set; }

    /// <summary>
    /// use [x] in array paths (e.g. for SpringBoot)
    /// </summary>
    [CliFlag("--properties-array-brackets")]
    public bool? PropertiesArrayBrackets { get; set; }

    /// <summary>
    /// separator to use between keys and values (default " = ")
    /// </summary>
    [CliOption("--properties-separator", Format = OptionFormat.EqualsSeparated)]
    public string? PropertiesSeparator { get; set; }

    /// <summary>
    /// Disable env related operations.
    /// </summary>
    [CliFlag("--security-disable-env-ops")]
    public bool? SecurityDisableEnvOps { get; set; }

    /// <summary>
    /// Disable file related operations (e.g. load)
    /// </summary>
    [CliFlag("--security-disable-file-ops")]
    public bool? SecurityDisableFileOps { get; set; }

    /// <summary>
    /// separator for shell variable key paths (default "_")
    /// </summary>
    [CliOption("--shell-key-separator", Format = OptionFormat.EqualsSeparated)]
    public string? ShellKeySeparator { get; set; }

    /// <summary>
    /// print each result (or doc) into a file named (exp). [exp] argument must return a string. You can use $index in the expression as the result counter. The necessary directories will be created.
    /// </summary>
    [CliOption("--split-exp", ShortForm = "-s", Format = OptionFormat.EqualsSeparated)]
    public string? SplitExp { get; set; }

    /// <summary>
    /// Use a file to specify the split-exp expression.
    /// </summary>
    [CliOption("--split-exp-file", Format = OptionFormat.EqualsSeparated)]
    public string? SplitExpFile { get; set; }

    /// <summary>
    /// Toggles strings interpolation of \(exp) (default true)
    /// </summary>
    [CliFlag("--string-interpolation")]
    public bool? StringInterpolation { get; set; }

    /// <summary>
    /// parse TSV YAML/JSON values (default true)
    /// </summary>
    [CliFlag("--tsv-auto-parse")]
    public bool? TsvAutoParse { get; set; }

    /// <summary>
    /// unwrap scalar, print the value with no quotes, colours or comments. Defaults to true for yaml (default true)
    /// </summary>
    [CliFlag("--unwrapScalar", ShortForm = "-r")]
    public bool? Unwrapscalar { get; set; }

    /// <summary>
    /// verbose mode
    /// </summary>
    [CliFlag("--verbose", ShortForm = "-v")]
    public bool? Verbose { get; set; }

    /// <summary>
    /// prefix for xml attributes (default "+@")
    /// </summary>
    [CliOption("--xml-attribute-prefix", Format = OptionFormat.EqualsSeparated)]
    public string? XmlAttributePrefix { get; set; }

    /// <summary>
    /// name for xml content (if no attribute name is present). (default "+content")
    /// </summary>
    [CliOption("--xml-content-name", Format = OptionFormat.EqualsSeparated)]
    public string? XmlContentName { get; set; }

    /// <summary>
    /// name for xml directives (e.g. &lt;!DOCTYPE thing cat&gt;) (default "+directive")
    /// </summary>
    [CliOption("--xml-directive-name", Format = OptionFormat.EqualsSeparated)]
    public string? XmlDirectiveName { get; set; }

    /// <summary>
    /// enables keeping namespace after parsing attributes (default true)
    /// </summary>
    [CliFlag("--xml-keep-namespace")]
    public bool? XmlKeepNamespace { get; set; }

    /// <summary>
    /// prefix for xml processing instructions (e.g. &lt;?xml version="1"?&gt;) (default "+p_")
    /// </summary>
    [CliOption("--xml-proc-inst-prefix", Format = OptionFormat.EqualsSeparated)]
    public string? XmlProcInstPrefix { get; set; }

    /// <summary>
    /// enables using RawToken method instead Token. Commonly disables namespace translations. See https://pkg.go.dev/encoding/xml#Decoder.RawToken for details. (default true)
    /// </summary>
    [CliFlag("--xml-raw-token")]
    public bool? XmlRawToken { get; set; }

    /// <summary>
    /// skip over directives (e.g. &lt;!DOCTYPE thing cat&gt;)
    /// </summary>
    [CliFlag("--xml-skip-directives")]
    public bool? XmlSkipDirectives { get; set; }

    /// <summary>
    /// skip over process instructions (e.g. &lt;?xml version="1"?&gt;)
    /// </summary>
    [CliFlag("--xml-skip-proc-inst")]
    public bool? XmlSkipProcInst { get; set; }

    /// <summary>
    /// enables strict parsing of XML. See https://pkg.go.dev/encoding/xml for more details.
    /// </summary>
    [CliFlag("--xml-strict-mode")]
    public bool? XmlStrictMode { get; set; }

    /// <summary>
    /// Use compact sequence indentation where '- ' is considered part of the indentation.
    /// </summary>
    [CliFlag("--yaml-compact-seq-indent", ShortForm = "-c")]
    public bool? YamlCompactSeqIndent { get; set; }

    /// <summary>
    /// Fix merge anchor to match YAML spec. Will default to true in late 2025
    /// </summary>
    [CliFlag("--yaml-fix-merge-anchor-to-spec")]
    public bool? YamlFixMergeAnchorToSpec { get; set; }

}
