// <auto-generated>
// This file was generated by ModularPipelines.OptionsGenerator.
// Do not edit this file manually.
// </auto-generated>

using ModularPipelines.Context;
using ModularPipelines.Models;
using ModularPipelines.Options;
using ModularPipelines.DotNet.Options;

namespace ModularPipelines.DotNet.Services;

/// <summary>
/// Generated implementation for dotnet CLI commands.
/// </summary>
internal partial class DotNet : IDotNet
{
    private readonly ICommand _command;

    /// <summary>
    /// Initializes a new instance of the <see cref="DotNet"/> class.
    /// </summary>
    public DotNet(
        DotNetBuildserver buildserver,
        DotNetNew @new,
        DotNetNuget nuget,
        DotNetPackage package,
        DotNetReference reference,
        DotNetSdk sdk,
        DotNetSolution solution,
        DotNetTool tool,
        DotNetWorkload workload,
        ICommand command
    )
    {
        Buildserver = buildserver;
        New = @new;
        Nuget = nuget;
        Package = package;
        Reference = reference;
        Sdk = sdk;
        Solution = solution;
        Tool = tool;
        Workload = workload;
        _command = command;
    }

    #region Sub-domain Services

    /// <inheritdoc />
    public DotNetBuildserver Buildserver { get; }

    /// <inheritdoc />
    public DotNetNew New { get; }

    /// <inheritdoc />
    public DotNetNuget Nuget { get; }

    /// <inheritdoc />
    public DotNetPackage Package { get; }

    /// <inheritdoc />
    public DotNetReference Reference { get; }

    /// <inheritdoc />
    public DotNetSdk Sdk { get; }

    /// <inheritdoc />
    public DotNetSolution Solution { get; }

    /// <inheritdoc />
    public DotNetTool Tool { get; }

    /// <inheritdoc />
    public DotNetWorkload Workload { get; }

    #endregion

    #region Commands

    /// <inheritdoc />
    public virtual async Task<CommandResult> Build(
        DotNetBuildOptions? options = default,
        CommandExecutionOptions? executionOptions = null,
        CancellationToken cancellationToken = default)
    {
        return await _command.ExecuteCommandLineTool(options ?? new DotNetBuildOptions(), executionOptions, cancellationToken);
    }

    /// <inheritdoc />
    public virtual async Task<CommandResult> Clean(
        DotNetCleanOptions? options = default,
        CommandExecutionOptions? executionOptions = null,
        CancellationToken cancellationToken = default)
    {
        return await _command.ExecuteCommandLineTool(options ?? new DotNetCleanOptions(), executionOptions, cancellationToken);
    }

    /// <inheritdoc />
    public virtual async Task<CommandResult> Format(
        DotNetFormatOptions? options = default,
        CommandExecutionOptions? executionOptions = null,
        CancellationToken cancellationToken = default)
    {
        return await _command.ExecuteCommandLineTool(options ?? new DotNetFormatOptions(), executionOptions, cancellationToken);
    }

    /// <inheritdoc />
    public virtual async Task<CommandResult> Msbuild(
        DotNetMsbuildOptions? options = default,
        CommandExecutionOptions? executionOptions = null,
        CancellationToken cancellationToken = default)
    {
        return await _command.ExecuteCommandLineTool(options ?? new DotNetMsbuildOptions(), executionOptions, cancellationToken);
    }

    /// <inheritdoc />
    public virtual async Task<CommandResult> Pack(
        DotNetPackOptions? options = default,
        CommandExecutionOptions? executionOptions = null,
        CancellationToken cancellationToken = default)
    {
        return await _command.ExecuteCommandLineTool(options ?? new DotNetPackOptions(), executionOptions, cancellationToken);
    }

    /// <inheritdoc />
    public virtual async Task<CommandResult> Publish(
        DotNetPublishOptions? options = default,
        CommandExecutionOptions? executionOptions = null,
        CancellationToken cancellationToken = default)
    {
        return await _command.ExecuteCommandLineTool(options ?? new DotNetPublishOptions(), executionOptions, cancellationToken);
    }

    /// <inheritdoc />
    public virtual async Task<CommandResult> Restore(
        DotNetRestoreOptions? options = default,
        CommandExecutionOptions? executionOptions = null,
        CancellationToken cancellationToken = default)
    {
        return await _command.ExecuteCommandLineTool(options ?? new DotNetRestoreOptions(), executionOptions, cancellationToken);
    }

    /// <inheritdoc />
    public virtual async Task<CommandResult> Run(
        DotNetRunOptions? options = default,
        CommandExecutionOptions? executionOptions = null,
        CancellationToken cancellationToken = default)
    {
        return await _command.ExecuteCommandLineTool(options ?? new DotNetRunOptions(), executionOptions, cancellationToken);
    }

    /// <inheritdoc />
    public virtual async Task<CommandResult> Store(
        DotNetStoreOptions? options = default,
        CommandExecutionOptions? executionOptions = null,
        CancellationToken cancellationToken = default)
    {
        return await _command.ExecuteCommandLineTool(options ?? new DotNetStoreOptions(), executionOptions, cancellationToken);
    }

    /// <inheritdoc />
    public virtual async Task<CommandResult> Test(
        DotNetTestOptions? options = default,
        CommandExecutionOptions? executionOptions = null,
        CancellationToken cancellationToken = default)
    {
        return await _command.ExecuteCommandLineTool(options ?? new DotNetTestOptions(), executionOptions, cancellationToken);
    }

    /// <inheritdoc />
    public virtual async Task<CommandResult> Vstest(
        DotNetVstestOptions? options = default,
        CommandExecutionOptions? executionOptions = null,
        CancellationToken cancellationToken = default)
    {
        return await _command.ExecuteCommandLineTool(options ?? new DotNetVstestOptions(), executionOptions, cancellationToken);
    }

    #endregion
}
