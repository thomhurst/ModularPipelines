// <auto-generated>
// This file was generated by ModularPipelines.OptionsGenerator.
// Do not edit this file manually.
// </auto-generated>

#nullable enable

using System.CodeDom.Compiler;
using System.Diagnostics.CodeAnalysis;
using ModularPipelines.Attributes;
using ModularPipelines.Skopeo.Options;

namespace ModularPipelines.Skopeo.Options;

/// <summary>
/// Container "IMAGE-NAME" uses a "transport":"details" format.
/// </summary>
[GeneratedCode("ModularPipelines.OptionsGenerator", "1.0.0")]
[ExcludeFromCodeCoverage]
[CliSubCommand("copy")]
public record SkopeoCopyOptions : SkopeoOptions
{
    /// <summary>
    /// additional tags (supports docker-archive)
    /// </summary>
    [CliOption("--additional-tag", Format = OptionFormat.EqualsSeparated, AllowMultiple = true)]
    public IEnumerable<string>? AdditionalTag { get; set; }

    /// <summary>
    /// Copy all images if SOURCE-IMAGE is a list
    /// </summary>
    [CliFlag("--all", ShortForm = "-a")]
    public bool? All { get; set; }

    /// <summary>
    /// path of the authentication file. Default is ${XDG_RUNTIME_DIR}/containers/auth.json
    /// </summary>
    [CliOption("--authfile", Format = OptionFormat.EqualsSeparated)]
    public string? Authfile { get; set; }

    /// <summary>
    /// *Experimental* key needed to decrypt the image
    /// </summary>
    [CliOption("--decryption-key", Format = OptionFormat.EqualsSeparated, AllowMultiple = true)]
    public IEnumerable<string>? DecryptionKey { get; set; }

    /// <summary>
    /// path of the authentication file. Default is ${XDG_RUNTIME_DIR}/containers/auth.json
    /// </summary>
    [CliOption("--dest-authfile", Format = OptionFormat.EqualsSeparated)]
    public string? DestAuthfile { get; set; }

    /// <summary>
    /// use certificates at PATH (*.crt, *.cert, *.key) to connect to the registry or daemon
    /// </summary>
    [CliOption("--dest-cert-dir", Format = OptionFormat.EqualsSeparated)]
    public string? DestCertDir { get; set; }

    /// <summary>
    /// Compress tarball image layers when saving to directory using the 'dir' transport. (default is same compression type as source)
    /// </summary>
    [CliFlag("--dest-compress")]
    public bool? DestCompress { get; set; }

    /// <summary>
    /// FORMAT to use for the compression
    /// </summary>
    [CliOption("--dest-compress-format", Format = OptionFormat.EqualsSeparated)]
    public string? DestCompressFormat { get; set; }

    /// <summary>
    /// LEVEL to use for the compression
    /// </summary>
    [CliOption("--dest-compress-level", Format = OptionFormat.EqualsSeparated)]
    public string? DestCompressLevel { get; set; }

    /// <summary>
    /// Use USERNAME[:PASSWORD] for accessing the registry
    /// </summary>
    [CliOption("--dest-creds", Format = OptionFormat.EqualsSeparated)]
    public string? DestCreds { get; set; }

    /// <summary>
    /// use docker daemon host at HOST (docker-daemon: only)
    /// </summary>
    [CliOption("--dest-daemon-host", Format = OptionFormat.EqualsSeparated)]
    public string? DestDaemonHost { get; set; }

    /// <summary>
    /// Decompress tarball image layers when saving to directory using the 'dir' transport. (default is same compression type as source)
    /// </summary>
    [CliFlag("--dest-decompress")]
    public bool? DestDecompress { get; set; }

    /// <summary>
    /// Access the registry anonymously
    /// </summary>
    [CliFlag("--dest-no-creds")]
    public bool? DestNoCreds { get; set; }

    /// <summary>
    /// Allow uncompressed image layers when saving to an OCI image using the 'oci' transport. (default is to compress things that aren't compressed)
    /// </summary>
    [CliFlag("--dest-oci-accept-uncompressed-layers")]
    public bool? DestOciAcceptUncompressedLayers { get; set; }

    /// <summary>
    /// Password for accessing the registry
    /// </summary>
    [SecretValue]
    [CliOption("--dest-password", Format = OptionFormat.EqualsSeparated)]
    public string? DestPassword { get; set; }

    /// <summary>
    /// Precompute digests to prevent uploading layers already on the registry using the 'docker' transport.
    /// </summary>
    [CliFlag("--dest-precompute-digests")]
    public bool? DestPrecomputeDigests { get; set; }

    /// <summary>
    /// Provide a Bearer token for accessing the registry
    /// </summary>
    [SecretValue]
    [CliOption("--dest-registry-token", Format = OptionFormat.EqualsSeparated)]
    public string? DestRegistryToken { get; set; }

    /// <summary>
    /// DIRECTORY to use to share blobs across OCI repositories
    /// </summary>
    [CliOption("--dest-shared-blob-dir", Format = OptionFormat.EqualsSeparated)]
    public string? DestSharedBlobDir { get; set; }

    /// <summary>
    /// require HTTPS and verify certificates when talking to the container registry or daemon
    /// </summary>
    [CliFlag("--dest-tls-verify")]
    public bool? DestTlsVerify { get; set; }

    /// <summary>
    /// Username for accessing the registry
    /// </summary>
    [CliOption("--dest-username", Format = OptionFormat.EqualsSeparated)]
    public string? DestUsername { get; set; }

    /// <summary>
    /// Write the digest of the pushed image to the specified file
    /// </summary>
    [CliOption("--digestfile", Format = OptionFormat.EqualsSeparated)]
    public string? Digestfile { get; set; }

    /// <summary>
    /// *Experimental* the 0-indexed layer indices, with support for negative indexing (e.g. 0 is the first layer, -1 is the last layer)
    /// </summary>
    [CliOption("--encrypt-layer", Format = OptionFormat.EqualsSeparated)]
    public string? EncryptLayer { get; set; }

    /// <summary>
    /// *Experimental* key with the encryption protocol to use needed to encrypt the image (e.g. jwe:/path/to/key.pem)
    /// </summary>
    [CliOption("--encryption-key", Format = OptionFormat.EqualsSeparated, AllowMultiple = true)]
    public IEnumerable<string>? EncryptionKey { get; set; }

    /// <summary>
    /// MANIFEST TYPE (oci, v2s1, or v2s2) to use in the destination (default is manifest type of source, with fallbacks)
    /// </summary>
    [CliOption("--format", ShortForm = "-f", Format = OptionFormat.EqualsSeparated)]
    public string? Format { get; set; }

    /// <summary>
    /// help for copy
    /// </summary>
    [CliFlag("--help", ShortForm = "-h")]
    public bool? Help { get; set; }

    /// <summary>
    /// How to handle multi-architecture images (system, all, or index-only)
    /// </summary>
    [CliOption("--multi-arch", Format = OptionFormat.EqualsSeparated)]
    public string? MultiArch { get; set; }

    /// <summary>
    /// Preserve digests of images and lists
    /// </summary>
    [CliFlag("--preserve-digests")]
    public bool? PreserveDigests { get; set; }

    /// <summary>
    /// Suppress output information when copying images
    /// </summary>
    [CliFlag("--quiet", ShortForm = "-q")]
    public bool? Quiet { get; set; }

    /// <summary>
    /// Do not copy signatures from SOURCE-IMAGE
    /// </summary>
    [CliFlag("--remove-signatures")]
    public bool? RemoveSignatures { get; set; }

    /// <summary>
    /// the number of times to possibly retry
    /// </summary>
    [CliOption("--retry-times", Format = OptionFormat.EqualsSeparated)]
    public int? RetryTimes { get; set; }

    /// <summary>
    /// Sign the image using a GPG key with the specified FINGERPRINT
    /// </summary>
    [CliOption("--sign-by", Format = OptionFormat.EqualsSeparated)]
    public string? SignBy { get; set; }

    /// <summary>
    /// Sign the image using a sigstore parameter file at PATH
    /// </summary>
    [CliOption("--sign-by-sigstore", Format = OptionFormat.EqualsSeparated)]
    public string? SignBySigstore { get; set; }

    /// <summary>
    /// Sign the image using a sigstore private key at PATH
    /// </summary>
    [SecretValue]
    [CliOption("--sign-by-sigstore-private-key", Format = OptionFormat.EqualsSeparated)]
    public string? SignBySigstorePrivateKey { get; set; }

    /// <summary>
    /// Identity of signed image, must be a fully specified docker reference. Defaults to the target docker reference.
    /// </summary>
    [CliOption("--sign-identity", Format = OptionFormat.EqualsSeparated)]
    public string? SignIdentity { get; set; }

    /// <summary>
    /// Read a passphrase for signing an image from PATH
    /// </summary>
    [CliOption("--sign-passphrase-file", Format = OptionFormat.EqualsSeparated)]
    public string? SignPassphraseFile { get; set; }

    /// <summary>
    /// path of the authentication file. Default is ${XDG_RUNTIME_DIR}/containers/auth.json
    /// </summary>
    [CliOption("--src-authfile", Format = OptionFormat.EqualsSeparated)]
    public string? SrcAuthfile { get; set; }

    /// <summary>
    /// use certificates at PATH (*.crt, *.cert, *.key) to connect to the registry or daemon
    /// </summary>
    [CliOption("--src-cert-dir", Format = OptionFormat.EqualsSeparated)]
    public string? SrcCertDir { get; set; }

    /// <summary>
    /// Use USERNAME[:PASSWORD] for accessing the registry
    /// </summary>
    [CliOption("--src-creds", Format = OptionFormat.EqualsSeparated)]
    public string? SrcCreds { get; set; }

    /// <summary>
    /// use docker daemon host at HOST (docker-daemon: only)
    /// </summary>
    [CliOption("--src-daemon-host", Format = OptionFormat.EqualsSeparated)]
    public string? SrcDaemonHost { get; set; }

    /// <summary>
    /// Access the registry anonymously
    /// </summary>
    [CliFlag("--src-no-creds")]
    public bool? SrcNoCreds { get; set; }

    /// <summary>
    /// Password for accessing the registry
    /// </summary>
    [SecretValue]
    [CliOption("--src-password", Format = OptionFormat.EqualsSeparated)]
    public string? SrcPassword { get; set; }

    /// <summary>
    /// Provide a Bearer token for accessing the registry
    /// </summary>
    [SecretValue]
    [CliOption("--src-registry-token", Format = OptionFormat.EqualsSeparated)]
    public string? SrcRegistryToken { get; set; }

    /// <summary>
    /// DIRECTORY to use to share blobs across OCI repositories
    /// </summary>
    [CliOption("--src-shared-blob-dir", Format = OptionFormat.EqualsSeparated)]
    public string? SrcSharedBlobDir { get; set; }

    /// <summary>
    /// require HTTPS and verify certificates when talking to the container registry or daemon
    /// </summary>
    [CliFlag("--src-tls-verify")]
    public bool? SrcTlsVerify { get; set; }

    /// <summary>
    /// Username for accessing the registry
    /// </summary>
    [CliOption("--src-username", Format = OptionFormat.EqualsSeparated)]
    public string? SrcUsername { get; set; }

}
