using System.Linq;
using System.Text;

namespace ModularPipelines.SourceGenerator;

/// <summary>
/// Generates the BuildCommandLine() method for options classes.
/// </summary>
/// <remarks>
/// The method is named BuildCommandLine() instead of Build() to avoid conflicts with
/// options classes that have properties named "Build" (e.g., AptGetOptions has a Build
/// property for the --build flag). In C#, a property and parameterless method cannot
/// share the same name.
///
/// This method is internal infrastructure called by ICommandLineBuilder - users don't
/// call it directly on options instances. They pass options to command methods like
/// context.Git().Checkout(options).
/// </remarks>
internal static class BuildMethodGenerator
{
    /// <summary>
    /// Generates the source code for the BuildCommandLine() method.
    /// </summary>
    /// <param name="info">The options class information.</param>
    /// <returns>The generated source code.</returns>
    public static string Generate(OptionsClassInfo info)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        var hasNamespace = !string.IsNullOrEmpty(info.Namespace);
        if (hasNamespace)
        {
            sb.AppendLine($"namespace {info.Namespace};");
            sb.AppendLine();
        }

        sb.AppendLine($"partial record {info.ClassName}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Builds the command line arguments from this options instance.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public ModularPipelines.Models.CommandLine BuildCommandLine()");
        sb.AppendLine("    {");
        sb.AppendLine("        var args = new System.Collections.Generic.List<string>();");

        // Add subcommand parts
        foreach (var part in info.SubCommandParts)
        {
            sb.AppendLine($"        args.Add(\"{Escape(part)}\");");
        }

        // Add arguments by position first (ImmediatelyAfterCommand)
        var immediateArgs = info.Properties
            .Where(p => p.Kind == CliPropertyKind.Argument)
            .OrderBy(p => p.ArgumentPosition ?? 0);

        foreach (var prop in immediateArgs)
        {
            sb.AppendLine($"        if ({prop.Name} is not null) args.Add({prop.Name}?.ToString() ?? string.Empty);");
        }

        // Add flags
        foreach (var prop in info.Properties.Where(p => p.Kind == CliPropertyKind.Flag))
        {
            sb.AppendLine($"        if ({prop.Name} == true) args.Add(\"{prop.CliName}\");");
        }

        // Add options
        foreach (var prop in info.Properties.Where(p => p.Kind == CliPropertyKind.Option))
        {
            if (prop.AllowMultiple)
            {
                sb.AppendLine($"        if ({prop.Name} is not null)");
                sb.AppendLine("        {");
                sb.AppendLine($"            foreach (var item in {prop.Name})");
                sb.AppendLine("            {");
                sb.AppendLine($"                args.Add(\"{prop.CliName}\");");
                sb.AppendLine("                args.Add(item?.ToString() ?? \"\");");
                sb.AppendLine("            }");
                sb.AppendLine("        }");
            }
            else
            {
                sb.AppendLine($"        if ({prop.Name} is not null)");
                sb.AppendLine("        {");
                sb.AppendLine($"            args.Add(\"{prop.CliName}\");");
                sb.AppendLine($"            args.Add({prop.Name}?.ToString() ?? string.Empty);");
                sb.AppendLine("        }");
            }
        }

        // Tool name - use attribute or fallback
        if (info.ToolName != null)
        {
            sb.AppendLine($"        return new ModularPipelines.Models.CommandLine(\"{Escape(info.ToolName)}\", args);");
        }
        else
        {
            sb.AppendLine("        return new ModularPipelines.Models.CommandLine(Tool ?? throw new System.InvalidOperationException(\"Tool name not specified\"), args);");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// Escapes special characters in a string for use in generated code.
    /// </summary>
    private static string Escape(string value) => value.Replace("\\", "\\\\").Replace("\"", "\\\"");
}
