"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[216],{5105:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>a,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"how-to/hooks","title":"Hooks","description":"Module Hooks","source":"@site/docs/how-to/hooks.md","sourceDirName":"how-to","slug":"/how-to/hooks","permalink":"/ModularPipelines/docs/how-to/hooks","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Hooks"},"sidebar":"tutorialSidebar","previous":{"title":"Custom Commands","permalink":"/ModularPipelines/docs/how-to/custom-commands"},"next":{"title":"Ignoring Failures","permalink":"/ModularPipelines/docs/how-to/ignoring-failures"}}');var t=n(4848),l=n(8453);const i={title:"Hooks"},r="Hooks",a={},d=[{value:"Module Hooks",id:"module-hooks",level:2},{value:"Overriding",id:"overriding",level:3},{value:"Hooks class",id:"hooks-class",level:3},{value:"Global Hooks",id:"global-hooks",level:2}];function c(e){const o={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(o.header,{children:(0,t.jsx)(o.h1,{id:"hooks",children:"Hooks"})}),"\n",(0,t.jsx)(o.h2,{id:"module-hooks",children:"Module Hooks"}),"\n",(0,t.jsx)(o.p,{children:"There are two ways to register hooks for a module:"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsx)(o.li,{children:"via a ModuleHooks class that is invoked before and after every module"}),"\n",(0,t.jsx)(o.li,{children:"Override the Before/After methods within a module"}),"\n"]}),"\n",(0,t.jsx)(o.h3,{id:"overriding",children:"Overriding"}),"\n",(0,t.jsx)(o.p,{children:"Overriding in modules allows for specific behaviour per module, that won't affect other modules.\ne.g."}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-csharp",children:'public class MyModule : Module\n{\n    protected override Task OnBeforeExecute(IPipelineContext context)\n    {\n        context.Logger.LogInformation("MyModule started!");\n        return Task.CompletedTask;\n    }\n\n    protected override Task OnAfterExecute(IPipelineContext context)\n    {\n        context.Logger.LogInformation("MyModule ended!");\n        return Task.CompletedTask;\n    }\n\n    protected override Task<IDictionary<string, object>?> ExecuteAsync(IPipelineContext context, CancellationToken cancellationToken)\n    {\n        return NothingAsync();\n    }\n}\n'})}),"\n",(0,t.jsx)(o.h3,{id:"hooks-class",children:"Hooks class"}),"\n",(0,t.jsx)(o.p,{children:"If we want to have repeat behaviour for every module, we can register some 'Hook' classes during startup."}),"\n",(0,t.jsx)(o.p,{children:"Pipeline Global Hooks will run once, before any modules have started, and/or after all modules have finished. Pipeline Module Hooks will run repeatedly, before every module, and/or after every module."}),"\n",(0,t.jsx)(o.p,{children:"This can be useful if you want some repeated action for every module. E.g. standard logging behaviour."}),"\n",(0,t.jsxs)(o.p,{children:["To do so, simply create a class that implements ",(0,t.jsx)(o.code,{children:"IPipelineModuleHooks"}),"."]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-csharp",children:"collection.AddPipelineModuleHooks<MyModuleHooks>();\n"})}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-csharp",children:'public class MyModuleHooks : IPipelineModuleHooks\n{\n    public Task OnBeforeModuleStartAsync(IPipelineHookContext context, IModule module)\n    {\n        context.Logger.LogInformation("{Module} is starting", module.GetType().Name);\n        return Task.CompletedTask;\n    }\n\n    public Task OnBeforeModuleEndAsync(IPipelineHookContext context, IModule module)\n    {\n        context.Logger.LogInformation("{Module} finished after {Elapsed}", module.GetType().Name, module.Duration);\n        return Task.CompletedTask;\n    }\n}\n'})}),"\n",(0,t.jsx)(o.h2,{id:"global-hooks",children:"Global Hooks"}),"\n",(0,t.jsxs)(o.p,{children:["Global hooks can be registered by creating a class that implements the ",(0,t.jsx)(o.code,{children:"IPipelineGlobalHooks"})," interface."]}),"\n",(0,t.jsx)(o.p,{children:"These are similar to the module hooks, but instead of running before and after EACH module, they run before and after ALL modules. So think of them more as a pipeline start up, and a pipeline finish hook."}),"\n",(0,t.jsx)(o.p,{children:"The end hook also gives you access to a Pipeline summary object. Giving you information such as pass/fail, duration, start and end, etc."}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-csharp",children:"collection.AddPipelineGlobalHooks<MyGlobalHooks>();\n"})}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-csharp",children:'public class MyGlobalHooks : IPipelineGlobalHooks\n{\n    public Task OnStartAsync(IPipelineHookContext pipelineContext)\n    {\n        pipelineContext.Logger.LogInformation("Pipeline is starting");\n        return Task.CompletedTask;\n    }\n\n    public Task OnEndAsync(IPipelineHookContext pipelineContext, PipelineSummary pipelineSummary)\n    {\n        pipelineContext.Logger.LogInformation("Pipeline is ending");\n        return Task.CompletedTask;\n    }\n}\n'})})]})}function u(e={}){const{wrapper:o}={...(0,l.R)(),...e.components};return o?(0,t.jsx)(o,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,o,n)=>{n.d(o,{R:()=>i,x:()=>r});var s=n(6540);const t={},l=s.createContext(t);function i(e){const o=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function r(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(l.Provider,{value:o},e.children)}}}]);