"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[571],{4820:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>m});const i=JSON.parse('{"id":"how-to/time-estimator","title":"Time Estimator","description":"The time estimator is a class built by you, used to estimate times for modules for displaying in the console progress dialog. It isn\'t mandatory, but without it, estimated times will not be correct.","source":"@site/docs/how-to/time-estimator.md","sourceDirName":"how-to","slug":"/how-to/time-estimator","permalink":"/ModularPipelines/docs/how-to/time-estimator","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Time Estimator"},"sidebar":"tutorialSidebar","previous":{"title":"Sub-Modules","permalink":"/ModularPipelines/docs/how-to/sub-modules"},"next":{"title":"Timeouts","permalink":"/ModularPipelines/docs/how-to/timeouts"}}');var a=n(4848),o=n(8453);const s={title:"Time Estimator"},r="Time Estimator",l={},m=[{value:"Example",id:"example",level:2}];function u(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"time-estimator",children:"Time Estimator"})}),"\n",(0,a.jsx)(t.p,{children:"The time estimator is a class built by you, used to estimate times for modules for displaying in the console progress dialog. It isn't mandatory, but without it, estimated times will not be correct."}),"\n",(0,a.jsx)(t.p,{children:"The idea is that on every run of a module, it takes note of how long it took to run, and then provides it to this class to save somewhere. That's up to you. A blob storage, a database, wherever."}),"\n",(0,a.jsx)(t.p,{children:"Then on subsequent runs, it'll ask you for an estimated time for a module. You go and pull this back out of your database or wherever, and then pass it back to the framework."}),"\n",(0,a.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:"await PipelineHostBuilder.Create()\n    .AddModule<Module1>()\n    .AddModule<Module2>()\n    .AddModule<Module3>()\n    .AddModuleEstimatedTimeProvider<MyEstimatedTimeProvider>()\n    .ExecutePipelineAsync();\n"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-csharp",children:'public class MyEstimatedTimeProvider : IModuleEstimatedTimeProvider\n{\n    private readonly string _directory = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),\n        "ModularPipelines", "EstimatedTimes");\n\n    public async Task<TimeSpan> GetModuleEstimatedTimeAsync(Type moduleType)\n    {\n        var fileName = $"{moduleType.FullName}.txt";\n        return await GetEstimatedTimeAsync(fileName);\n    }\n\n    public async Task SaveModuleTimeAsync(Type moduleType, TimeSpan duration)\n    {\n        var fileName = $"{moduleType.FullName}.txt";\n\n        await SaveModuleTimeAsync(duration, fileName);\n    }\n\n    public async Task<IEnumerable<SubModuleEstimation>> GetSubModuleEstimatedTimesAsync(Type moduleType)\n    {\n        var directoryInfo = new DirectoryInfo(_directory);\n\n        if (!directoryInfo.Exists)\n        {\n            directoryInfo.Create();\n        }\n\n        directoryInfo.Create();\n\n        var paths = directoryInfo\n            .EnumerateFiles("*.txt", SearchOption.TopDirectoryOnly)\n            .Where(x => x.Name.StartsWith($"Mod-{moduleType.FullName}"))\n            .ToList();\n\n        var subModuleEstimations = await paths.ToAsyncProcessorBuilder()\n            .SelectAsync(async file =>\n            {\n                try\n                {\n                    var name = Path.GetFileNameWithoutExtension(file.FullName).Split("-Sub-")[1];\n                    var time = await GetEstimatedTimeAsync(file.FullName);\n                    return new SubModuleEstimation(name, time);\n                }\n                catch\n                {\n                    File.Delete(file.FullName);\n                    return null;\n                }\n            })\n            .ProcessInParallel();\n\n        return subModuleEstimations.OfType<SubModuleEstimation>();\n    }\n\n    public async Task SaveSubModuleTimeAsync(Type moduleType, SubModuleEstimation subModuleEstimation)\n    {\n        var fileName = $"Mod-{moduleType.FullName}-Sub-{subModuleEstimation.SubModuleName}.txt";\n\n        await SaveModuleTimeAsync(subModuleEstimation.EstimatedDuration, fileName);\n    }\n\n    private async Task<TimeSpan> GetEstimatedTimeAsync(string fileName)\n    {\n        var path = Path.Combine(_directory, fileName);\n\n        if (File.Exists(path))\n        {\n            var contents = await File.ReadAllTextAsync(path);\n            return TimeSpan.Parse(contents);\n        }\n\n        // Some default fallback. We can\'t estimate for now so we\'ll estimate next time.\n        return TimeSpan.FromMinutes(2);\n    }\n\n    private async Task SaveModuleTimeAsync(TimeSpan duration, string fileName)\n    {\n        Directory.CreateDirectory(_directory);\n\n        var path = Path.Combine(_directory, fileName);\n\n        await File.WriteAllTextAsync(path, duration.ToString());\n    }\n}\n'})})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(6540);const a={},o=i.createContext(a);function s(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);