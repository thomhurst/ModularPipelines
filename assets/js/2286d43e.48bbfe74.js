"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[2205],{7873:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>d});const l=JSON.parse('{"id":"architecture/module-execution-lifecycle","title":"Module Execution Lifecycle","description":"This document describes the complete execution lifecycle of a module in ModularPipelines, including the order of operations for hooks, skip checks, retries, timeouts, and how different behavior interfaces interact with each other.","source":"@site/docs/architecture/module-execution-lifecycle.md","sourceDirName":"architecture","slug":"/architecture/module-execution-lifecycle","permalink":"/ModularPipelines/docs/architecture/module-execution-lifecycle","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Module Execution Lifecycle","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Why Modular Pipelines?","permalink":"/ModularPipelines/docs/why"}}');var s=i(4848),t=i(8453);const r={title:"Module Execution Lifecycle",sidebar_position:1},c="Module Execution Lifecycle",o={},d=[{value:"Overview",id:"overview",level:2},{value:"Execution Flow Diagram",id:"execution-flow-diagram",level:2},{value:"Detailed Phase Descriptions",id:"detailed-phase-descriptions",level:2},{value:"Phase 1: Dependency Resolution",id:"phase-1-dependency-resolution",level:3},{value:"Phase 2: Cancellation Setup",id:"phase-2-cancellation-setup",level:3},{value:"Phase 3: Skip Check",id:"phase-3-skip-check",level:3},{value:"Phase 4: Before Hooks",id:"phase-4-before-hooks",level:3},{value:"Phase 5: Execution with Policies",id:"phase-5-execution-with-policies",level:3},{value:"Timeout Application",id:"timeout-application",level:4},{value:"Retry Policy Application",id:"retry-policy-application",level:4},{value:"Phase 6: Failure Handling",id:"phase-6-failure-handling",level:3},{value:"Phase 7: After Hooks",id:"phase-7-after-hooks",level:3},{value:"Behavior Interaction Matrix",id:"behavior-interaction-matrix",level:2},{value:"Detailed Behavior Interaction Examples",id:"detailed-behavior-interaction-examples",level:2},{value:"IHookable + ISkippable",id:"ihookable--iskippable",level:3},{value:"IRetryable + ITimeoutable",id:"iretryable--itimeoutable",level:3},{value:"IHookable + IRetryable",id:"ihookable--iretryable",level:3},{value:"IAlwaysRun + ISkippable",id:"ialwaysrun--iskippable",level:3},{value:"IIgnoreFailures + IRetryable",id:"iignorefailures--iretryable",level:3},{value:"Hook Execution Order Summary",id:"hook-execution-order-summary",level:2},{value:"Edge Cases",id:"edge-cases",level:2},{value:"OnBeforeExecuteAsync Throws Exception",id:"onbeforeexecuteasync-throws-exception",level:3},{value:"AlwaysRun Module with Failed Dependencies",id:"alwaysrun-module-with-failed-dependencies",level:3},{value:"Timeout vs Cancellation",id:"timeout-vs-cancellation",level:3},{value:"Best Practices",id:"best-practices",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"module-execution-lifecycle",children:"Module Execution Lifecycle"})}),"\n",(0,s.jsx)(n.p,{children:"This document describes the complete execution lifecycle of a module in ModularPipelines, including the order of operations for hooks, skip checks, retries, timeouts, and how different behavior interfaces interact with each other."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"ModularPipelines modules can implement several behavior interfaces to customize their execution:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Interface"}),(0,s.jsx)(n.th,{children:"Purpose"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ISkippable"})}),(0,s.jsx)(n.td,{children:"Define conditions to skip module execution"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"IHookable"})}),(0,s.jsx)(n.td,{children:"Add before/after execution hooks"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ITimeoutable"})}),(0,s.jsx)(n.td,{children:"Set execution timeout"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"IRetryable<T>"})}),(0,s.jsx)(n.td,{children:"Configure retry policy"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"IIgnoreFailures"})}),(0,s.jsx)(n.td,{children:"Allow failures without failing the pipeline"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"IAlwaysRun"})}),(0,s.jsx)(n.td,{children:"Run even when pipeline fails"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"execution-flow-diagram",children:"Execution Flow Diagram"}),"\n",(0,s.jsx)(n.p,{children:"The following diagram shows the complete module execution lifecycle:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"                    Module Scheduled\n                          |\n                          v\n              +------------------------+\n              |  Wait for Dependencies |\n              +------------------------+\n                          |\n                          v\n              +------------------------+\n              | Setup Cancellation     |\n              | (IAlwaysRun check)     |\n              +------------------------+\n                          |\n                          v\n              +------------------------+\n              | ISkippable.ShouldSkip  |-----\x3e Skip? ---+\n              +------------------------+               |\n                          |                            |\n                          | No                         | Yes\n                          v                            v\n              +------------------------+    +-------------------+\n              | OnBeforeExecuteAsync   |    | OnSkippedAsync    |\n              | (direct hook)          |    | (direct hook)     |\n              +------------------------+    +-------------------+\n                          |                            |\n                          v                            v\n              +------------------------+    +-------------------+\n              | IHookable.OnBeforeExe  |    | Return Skipped    |\n              +------------------------+    | Result            |\n                          |                 +-------------------+\n                          v\n              +------------------------+\n              |    Start Stopwatch     |\n              |    Status=Processing   |\n              +------------------------+\n                          |\n                          v\n         +--------------------------------+\n         |   ExecuteWithPolicies          |\n         |   +-------------------------+  |\n         |   | Apply Timeout           |  |\n         |   | (ITimeoutable or 30min) |  |\n         |   +-------------------------+  |\n         |              |                 |\n         |              v                 |\n         |   +-------------------------+  |\n         |   | Apply Retry Policy      |  |\n         |   | (IRetryable or default) |  |\n         |   +-------------------------+  |\n         |              |                 |\n         |              v                 |\n         |   +-------------------------+  |\n         |   |    ExecuteAsync         |  |\n         |   +-------------------------+  |\n         +--------------------------------+\n                          |\n            +-------------+-------------+\n            |                           |\n         Success                     Exception\n            |                           |\n            v                           v\n  +------------------+       +--------------------+\n  | Status=Successful|       | OnFailedAsync      |\n  +------------------+       | (direct hook)      |\n            |                +--------------------+\n            |                           |\n            |                           v\n            |                +--------------------+\n            |                | IIgnoreFailures?   |----\x3e Yes: IgnoredFailure\n            |                +--------------------+\n            |                           |\n            |                        No |\n            |                           v\n            |                +--------------------+\n            |                | Status=Failed      |\n            |                | Cancel Pipeline    |\n            |                +--------------------+\n            |                           |\n            +-------------+-------------+\n                          |\n                          v\n              +------------------------+\n              | OnAfterExecuteAsync    |\n              | (direct hook)          |\n              +------------------------+\n                          |\n                          v\n              +------------------------+\n              | IHookable.OnAfterExe   |\n              | (in finally block)     |\n              +------------------------+\n                          |\n                          v\n                    Module Complete\n"})}),"\n",(0,s.jsx)(n.h2,{id:"detailed-phase-descriptions",children:"Detailed Phase Descriptions"}),"\n",(0,s.jsx)(n.h3,{id:"phase-1-dependency-resolution",children:"Phase 1: Dependency Resolution"}),"\n",(0,s.jsx)(n.p,{children:"Before a module begins execution, it waits for all its dependencies to complete:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Dependencies declared via ",(0,s.jsx)(n.code,{children:"[DependsOn<T>]"})," attributes are resolved"]}),"\n",(0,s.jsxs)(n.li,{children:["Dependencies declared via ",(0,s.jsx)(n.code,{children:"DeclareDependencies()"})," method are resolved"]}),"\n",(0,s.jsx)(n.li,{children:"The module waits until all dependencies have finished (success, failure, or skip)"}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"[NotInParallel]"})," is specified, the module waits for exclusive execution"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Exception for AlwaysRun modules"}),": When a pipeline fails and AlwaysRun modules are executed late, they skip dependency waiting to prevent deadlocks."]}),"\n",(0,s.jsx)(n.h3,{id:"phase-2-cancellation-setup",children:"Phase 2: Cancellation Setup"}),"\n",(0,s.jsxs)(n.p,{children:["The cancellation token is configured based on whether the module implements ",(0,s.jsx)(n.code,{children:"IAlwaysRun"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Normal modules"}),": Linked to the engine cancellation token (cancelled when any module fails)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"AlwaysRun modules"}),": Not linked to engine cancellation (runs even after pipeline failure)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-3-skip-check",children:"Phase 3: Skip Check"}),"\n",(0,s.jsxs)(n.p,{children:["If the module implements ",(0,s.jsx)(n.code,{children:"ISkippable"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ShouldSkip(IModuleContext)"})," is called"]}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"SkipDecision.ShouldSkip"})," is true:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OnSkippedAsync"})," (direct hook) is called"]}),"\n",(0,s.jsx)(n.li,{children:"If a result repository is configured, historical results may be returned"}),"\n",(0,s.jsxs)(n.li,{children:["The module is marked as ",(0,s.jsx)(n.code,{children:"Skipped"})," and execution ends"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Important"}),": When a module is skipped, neither ",(0,s.jsx)(n.code,{children:"OnBeforeExecuteAsync"})," nor ",(0,s.jsx)(n.code,{children:"IHookable.OnBeforeExecute"})," are called."]}),"\n",(0,s.jsx)(n.h3,{id:"phase-4-before-hooks",children:"Phase 4: Before Hooks"}),"\n",(0,s.jsx)(n.p,{children:"Hooks execute in this order:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"OnBeforeExecuteAsync"})," (direct virtual method override)"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Exceptions here ",(0,s.jsx)(n.strong,{children:"prevent"})," execution and are propagated as module failure"]}),"\n",(0,s.jsxs)(n.li,{children:["Neither ",(0,s.jsx)(n.code,{children:"OnFailedAsync"})," nor ",(0,s.jsx)(n.code,{children:"OnAfterExecuteAsync"})," will be called"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"IHookable.OnBeforeExecute"})," (interface implementation)"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Runs after the direct hook"}),"\n",(0,s.jsx)(n.li,{children:"Exceptions are propagated"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-5-execution-with-policies",children:"Phase 5: Execution with Policies"}),"\n",(0,s.jsxs)(n.p,{children:["The actual ",(0,s.jsx)(n.code,{children:"ExecuteAsync"})," method is wrapped with timeout and retry policies:"]}),"\n",(0,s.jsx)(n.h4,{id:"timeout-application",children:"Timeout Application"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"ITimeoutable"})," is implemented, use the specified ",(0,s.jsx)(n.code,{children:"Timeout"})," property"]}),"\n",(0,s.jsx)(n.li,{children:"Otherwise, use the default timeout of 30 minutes"}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"TimeSpan.Zero"})," to disable timeout (not recommended)"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"retry-policy-application",children:"Retry Policy Application"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"IRetryable<T>"})," is implemented, use the custom retry policy"]}),"\n",(0,s.jsxs)(n.li,{children:["Otherwise, if ",(0,s.jsx)(n.code,{children:"PipelineOptions.DefaultRetryCount > 0"}),", use default retry policy"]}),"\n",(0,s.jsx)(n.li,{children:"Otherwise, no retries are attempted"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"The timeout wraps the entire retry operation"}),", meaning the timeout applies to the total execution time including all retries."]}),"\n",(0,s.jsx)(n.h3,{id:"phase-6-failure-handling",children:"Phase 6: Failure Handling"}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"ExecuteAsync"})," throws an exception:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"OnFailedAsync"})," (direct hook) is called first"]}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"IIgnoreFailures"})," is implemented:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ShouldIgnoreFailures(context, exception)"})," is called"]}),"\n",(0,s.jsxs)(n.li,{children:["If true, status is set to ",(0,s.jsx)(n.code,{children:"IgnoredFailure"})," and pipeline continues"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"If failure is not ignored, the pipeline is cancelled"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"phase-7-after-hooks",children:"Phase 7: After Hooks"}),"\n",(0,s.jsx)(n.p,{children:"Regardless of success or failure, after hooks run:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"OnAfterExecuteAsync"})," (direct hook)"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Only runs if ",(0,s.jsx)(n.code,{children:"OnBeforeExecuteAsync"})," completed successfully"]}),"\n",(0,s.jsxs)(n.li,{children:["Receives the ",(0,s.jsx)(n.code,{children:"ModuleResult<T>"})," (success or failure)"]}),"\n",(0,s.jsx)(n.li,{children:"Can modify and return a new result"}),"\n",(0,s.jsx)(n.li,{children:"Exceptions are logged but don't affect the result"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"IHookable.OnAfterExecute"})," (in finally block)"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Always runs if before hooks executed"}),"\n",(0,s.jsxs)(n.li,{children:["Runs even if ",(0,s.jsx)(n.code,{children:"OnAfterExecuteAsync"})," threw an exception"]}),"\n",(0,s.jsx)(n.li,{children:"Exceptions are logged but don't affect the result"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"behavior-interaction-matrix",children:"Behavior Interaction Matrix"}),"\n",(0,s.jsx)(n.p,{children:"This table shows how different behavior combinations interact:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Combination"}),(0,s.jsx)(n.th,{children:"Behavior"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"IHookable + ISkippable"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"OnBeforeExecute"})," does NOT run if module is skipped. Skip check happens before hooks."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"IRetryable + ITimeoutable"})}),(0,s.jsx)(n.td,{children:"Timeout applies to TOTAL execution time (all retries combined), not per-retry."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"IHookable + IRetryable"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"OnBeforeExecute"})," runs ONCE before any retries. ",(0,s.jsx)(n.code,{children:"OnAfterExecute"})," runs ONCE after all retries complete."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"IAlwaysRun + ISkippable"})}),(0,s.jsx)(n.td,{children:"Skip check still runs. AlwaysRun only affects cancellation, not skip logic. Both can be combined."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"IIgnoreFailures + IRetryable"})}),(0,s.jsxs)(n.td,{children:["Retries happen first. If all retries fail, then ",(0,s.jsx)(n.code,{children:"IIgnoreFailures"})," is checked."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"IAlwaysRun + IIgnoreFailures"})}),(0,s.jsx)(n.td,{children:"Both apply. AlwaysRun prevents cancellation from other failures; IIgnoreFailures prevents this module's failure from cancelling others."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.strong,{children:"ITimeoutable + IAlwaysRun"})}),(0,s.jsx)(n.td,{children:"Timeout still applies. AlwaysRun only affects pipeline cancellation, not module timeout."})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"detailed-behavior-interaction-examples",children:"Detailed Behavior Interaction Examples"}),"\n",(0,s.jsx)(n.h3,{id:"ihookable--iskippable",children:"IHookable + ISkippable"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class MyModule : Module<string>, IHookable, ISkippable\n{\n    public Task<SkipDecision> ShouldSkip(IPipelineContext context)\n    {\n        // This runs FIRST\n        return SkipDecision.Skip("Not needed").AsTask();\n    }\n\n    public Task OnBeforeExecute(IPipelineContext context)\n    {\n        // This does NOT run when skipped\n        return Task.CompletedTask;\n    }\n\n    public Task OnAfterExecute(IPipelineContext context)\n    {\n        // This does NOT run when skipped\n        return Task.CompletedTask;\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Result"}),": When ",(0,s.jsx)(n.code,{children:"ShouldSkip"})," returns true, neither ",(0,s.jsx)(n.code,{children:"OnBeforeExecute"})," nor ",(0,s.jsx)(n.code,{children:"OnAfterExecute"})," are called."]}),"\n",(0,s.jsx)(n.h3,{id:"iretryable--itimeoutable",children:"IRetryable + ITimeoutable"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class MyModule : Module<string>, IRetryable<string>, ITimeoutable\n{\n    public TimeSpan Timeout => TimeSpan.FromSeconds(30);\n\n    public AsyncRetryPolicy<string?> GetRetryPolicy(IPipelineContext context)\n    {\n        return Policy<string?>\n            .Handle<HttpRequestException>()\n            .WaitAndRetryAsync(3, i => TimeSpan.FromSeconds(i));\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Result"}),": The 30-second timeout applies to the TOTAL execution time. If each retry takes 10 seconds with 3-second waits between retries, you could timeout during the second retry attempt."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Timeline:\n0s  - Attempt 1 starts\n10s - Attempt 1 fails, wait 1s\n11s - Attempt 2 starts\n21s - Attempt 2 fails, wait 2s\n23s - Attempt 3 starts\n30s - TIMEOUT! (even though attempt 3 might succeed at 33s)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"ihookable--iretryable",children:"IHookable + IRetryable"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class MyModule : Module<string>, IHookable, IRetryable<string>\n{\n    private int _beforeCount = 0;\n    private int _afterCount = 0;\n\n    public Task OnBeforeExecute(IPipelineContext context)\n    {\n        _beforeCount++; // Called ONCE, regardless of retries\n        return Task.CompletedTask;\n    }\n\n    public Task OnAfterExecute(IPipelineContext context)\n    {\n        _afterCount++; // Called ONCE, after all retries complete\n        return Task.CompletedTask;\n    }\n\n    public AsyncRetryPolicy<string?> GetRetryPolicy(IPipelineContext context)\n    {\n        return Policy<string?>.Handle<Exception>().RetryAsync(3);\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Result"}),": Hooks run once, not per-retry:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OnBeforeExecute"}),": Called once before first attempt"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ExecuteAsync"}),": May be called 1-4 times (initial + 3 retries)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OnAfterExecute"}),": Called once after final attempt (success or failure)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"ialwaysrun--iskippable",children:"IAlwaysRun + ISkippable"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class CleanupModule : Module<string>, IAlwaysRun, ISkippable\n{\n    public Task<SkipDecision> ShouldSkip(IPipelineContext context)\n    {\n        // Skip logic still applies to AlwaysRun modules\n        if (context.Environment.IsDevelopment())\n        {\n            return SkipDecision.Skip("No cleanup in dev").AsTask();\n        }\n        return SkipDecision.DoNotSkip.AsTask();\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Result"}),": Both behaviors apply independently:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IAlwaysRun"}),": Module won't be cancelled when other modules fail"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ISkippable"}),": Module can still be skipped based on custom logic"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"iignorefailures--iretryable",children:"IIgnoreFailures + IRetryable"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class ResilientModule : Module<string>, IRetryable<string>, IIgnoreFailures\n{\n    public AsyncRetryPolicy<string?> GetRetryPolicy(IPipelineContext context)\n    {\n        return Policy<string?>.Handle<Exception>().RetryAsync(3);\n    }\n\n    public Task<bool> ShouldIgnoreFailures(IPipelineContext context, Exception exception)\n    {\n        // This is only called AFTER all retries are exhausted\n        return Task.FromResult(true);\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Result"}),": Order of operations:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Attempt execution"}),"\n",(0,s.jsx)(n.li,{children:"On failure, retry up to 3 times"}),"\n",(0,s.jsxs)(n.li,{children:["If all 4 attempts fail, check ",(0,s.jsx)(n.code,{children:"ShouldIgnoreFailures"})]}),"\n",(0,s.jsxs)(n.li,{children:["If ignored, status = ",(0,s.jsx)(n.code,{children:"IgnoredFailure"}),", pipeline continues"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"hook-execution-order-summary",children:"Hook Execution Order Summary"}),"\n",(0,s.jsx)(n.p,{children:"For a module that implements all behaviors and runs successfully:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"1. Wait for dependencies\n2. Setup cancellation (check IAlwaysRun)\n3. ISkippable.ShouldSkip() [if implemented]\n4. OnBeforeExecuteAsync() [direct hook]\n5. IHookable.OnBeforeExecute() [if implemented]\n6. Start timing\n7. Apply timeout + retry wrapper\n8. ExecuteAsync() [may retry multiple times]\n9. Stop timing\n10. OnAfterExecuteAsync() [direct hook]\n11. IHookable.OnAfterExecute() [in finally block]\n"})}),"\n",(0,s.jsx)(n.p,{children:"For a module that fails:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"1-7. Same as above\n8. ExecuteAsync() fails after retries\n9. OnFailedAsync() [direct hook]\n10. IIgnoreFailures.ShouldIgnoreFailures() [if implemented]\n11. If not ignored: Cancel pipeline\n12. OnAfterExecuteAsync() [direct hook]\n13. IHookable.OnAfterExecute() [in finally block]\n"})}),"\n",(0,s.jsx)(n.p,{children:"For a module that is skipped:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"1. Wait for dependencies\n2. Setup cancellation\n3. ISkippable.ShouldSkip() returns true\n4. OnSkippedAsync() [direct hook]\n5. Check result repository for historical data\n6. Return skipped result\n"})}),"\n",(0,s.jsx)(n.h2,{id:"edge-cases",children:"Edge Cases"}),"\n",(0,s.jsx)(n.h3,{id:"onbeforeexecuteasync-throws-exception",children:"OnBeforeExecuteAsync Throws Exception"}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"OnBeforeExecuteAsync"})," throws:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ExecuteAsync"})," is NOT called"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OnFailedAsync"})," is NOT called (module never started)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OnAfterExecuteAsync"})," is NOT called (before hooks didn't complete)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IHookable.OnAfterExecute"})," IS still called (in finally block)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"alwaysrun-module-with-failed-dependencies",children:"AlwaysRun Module with Failed Dependencies"}),"\n",(0,s.jsx)(n.p,{children:"When the pipeline fails and an AlwaysRun module hasn't started yet:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The module is started without waiting for dependencies"}),"\n",(0,s.jsx)(n.li,{children:"This prevents deadlocks where dependencies will never complete"}),"\n",(0,s.jsxs)(n.li,{children:["The module receives a fresh ",(0,s.jsx)(n.code,{children:"CancellationToken.None"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"timeout-vs-cancellation",children:"Timeout vs Cancellation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Timeout"}),": Module-specific limit on execution time"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cancellation"}),": Pipeline-wide signal when any module fails"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"AlwaysRun modules ignore pipeline cancellation but still respect their own timeout."}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use ISkippable for conditional execution"}),", not OnBeforeExecuteAsync"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Set reasonable timeouts"})," to prevent runaway modules"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use IIgnoreFailures for non-critical modules"})," like notifications"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Combine IAlwaysRun with IIgnoreFailures"})," for cleanup modules"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Keep hooks lightweight"})," - heavy logic belongs in ExecuteAsync"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Log in OnFailedAsync"})," for debugging failed modules"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consider total time when using IRetryable + ITimeoutable"})," together"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>c});var l=i(6540);const s={},t=l.createContext(s);function r(e){const n=l.useContext(t);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),l.createElement(t.Provider,{value:n},e.children)}}}]);