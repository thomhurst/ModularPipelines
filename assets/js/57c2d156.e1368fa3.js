"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[216],{9438:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var s=n(4848),t=n(8453);const i={title:"Hooks"},l="Hooks",r={id:"how-to/hooks",title:"Hooks",description:"Module Hooks",source:"@site/docs/how-to/hooks.md",sourceDirName:"how-to",slug:"/how-to/hooks",permalink:"/ModularPipelines/docs/how-to/hooks",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Hooks"},sidebar:"tutorialSidebar",previous:{title:"Execution and Dependencies",permalink:"/ModularPipelines/docs/how-to/execution-and-dependencies"},next:{title:"Ignoring Failures",permalink:"/ModularPipelines/docs/how-to/ignoring-failures"}},a={},d=[{value:"Module Hooks",id:"module-hooks",level:2},{value:"Overriding",id:"overriding",level:3},{value:"Hooks class",id:"hooks-class",level:3},{value:"Global Hooks",id:"global-hooks",level:2}];function c(e){const o={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(o.h1,{id:"hooks",children:"Hooks"}),"\n",(0,s.jsx)(o.h2,{id:"module-hooks",children:"Module Hooks"}),"\n",(0,s.jsx)(o.p,{children:"There are two ways to register hooks for a module:"}),"\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsx)(o.li,{children:"via a ModuleHooks class that is invoked before and after every module"}),"\n",(0,s.jsx)(o.li,{children:"Override the Before/After methods within a module"}),"\n"]}),"\n",(0,s.jsx)(o.h3,{id:"overriding",children:"Overriding"}),"\n",(0,s.jsx)(o.p,{children:"Overriding in modules allows for specific behaviour per module, that won't affect other modules.\ne.g."}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{className:"language-csharp",children:'public class MyModule : Module\n{\n    protected override Task OnBeforeExecute(IPipelineContext context)\n    {\n        context.Logger.LogInformation("MyModule started!");\n        return Task.CompletedTask;\n    }\n\n    protected override Task OnAfterExecute(IPipelineContext context)\n    {\n        context.Logger.LogInformation("MyModule ended!");\n        return Task.CompletedTask;\n    }\n\n    protected override Task<IDictionary<string, object>?> ExecuteAsync(IPipelineContext context, CancellationToken cancellationToken)\n    {\n        return NothingAsync();\n    }\n}\n'})}),"\n",(0,s.jsx)(o.h3,{id:"hooks-class",children:"Hooks class"}),"\n",(0,s.jsx)(o.p,{children:"If we want to have repeat behaviour for every module, we can register some 'Hook' classes during startup."}),"\n",(0,s.jsx)(o.p,{children:"Pipeline Global Hooks will run once, before any modules have started, and/or after all modules have finished. Pipeline Module Hooks will run repeatedly, before every module, and/or after every module."}),"\n",(0,s.jsx)(o.p,{children:"This can be useful if you want some repeated action for every module. E.g. standard logging behaviour."}),"\n",(0,s.jsxs)(o.p,{children:["To do so, simply create a class that implements ",(0,s.jsx)(o.code,{children:"IPipelineModuleHooks"}),"."]}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{className:"language-csharp",children:"collection.AddPipelineModuleHooks<MyModuleHooks>();\n"})}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{className:"language-csharp",children:'public class MyModuleHooks : IPipelineModuleHooks\n{\n    public Task OnBeforeModuleStartAsync(IPipelineHookContext context, IModule module)\n    {\n        context.Logger.LogInformation("{Module} is starting", module.GetType().Name);\n        return Task.CompletedTask;\n    }\n\n    public Task OnBeforeModuleEndAsync(IPipelineHookContext context, IModule module)\n    {\n        context.Logger.LogInformation("{Module} finished after {Elapsed}", module.GetType().Name, module.Duration);\n        return Task.CompletedTask;\n    }\n}\n'})}),"\n",(0,s.jsx)(o.h2,{id:"global-hooks",children:"Global Hooks"}),"\n",(0,s.jsxs)(o.p,{children:["Global hooks can be registered by creating a class that implements the ",(0,s.jsx)(o.code,{children:"IPipelineGlobalHooks"})," interface."]}),"\n",(0,s.jsx)(o.p,{children:"These are similar to the module hooks, but instead of running before and after EACH module, they run before and after ALL modules. So think of them more as a pipeline start up, and a pipeline finish hook."}),"\n",(0,s.jsx)(o.p,{children:"The end hook also gives you access to a Pipeline summary object. Giving you information such as pass/fail, duration, start and end, etc."}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{className:"language-csharp",children:"collection.AddPipelineGlobalHooks<MyGlobalHooks>();\n"})}),"\n",(0,s.jsx)(o.pre,{children:(0,s.jsx)(o.code,{className:"language-csharp",children:'public class MyGlobalHooks : IPipelineGlobalHooks\n{\n    public Task OnStartAsync(IPipelineHookContext pipelineContext)\n    {\n        pipelineContext.Logger.LogInformation("Pipeline is starting");\n        return Task.CompletedTask;\n    }\n\n    public Task OnEndAsync(IPipelineHookContext pipelineContext, PipelineSummary pipelineSummary)\n    {\n        pipelineContext.Logger.LogInformation("Pipeline is ending");\n        return Task.CompletedTask;\n    }\n}\n'})})]})}function u(e={}){const{wrapper:o}={...(0,t.R)(),...e.components};return o?(0,s.jsx)(o,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,o,n)=>{n.d(o,{R:()=>l,x:()=>r});var s=n(6540);const t={},i=s.createContext(t);function l(e){const o=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function r(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(i.Provider,{value:o},e.children)}}}]);