"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[3216],{5105:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>d});const l=JSON.parse('{"id":"how-to/hooks","title":"Hooks","description":"Module Hooks","source":"@site/docs/how-to/hooks.md","sourceDirName":"how-to","slug":"/how-to/hooks","permalink":"/ModularPipelines/docs/how-to/hooks","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Hooks"},"sidebar":"tutorialSidebar","previous":{"title":"Custom Commands","permalink":"/ModularPipelines/docs/how-to/custom-commands"},"next":{"title":"Ignoring Failures","permalink":"/ModularPipelines/docs/how-to/ignoring-failures"}}');var s=o(4848),t=o(8453);const i={title:"Hooks"},r="Hooks",c={},d=[{value:"Module Hooks",id:"module-hooks",level:2},{value:"Direct Module Hooks (Recommended)",id:"direct-module-hooks-recommended",level:3},{value:"ModuleConfiguration Hooks",id:"moduleconfiguration-hooks",level:3},{value:"Hooks class",id:"hooks-class",level:3},{value:"Global Hooks",id:"global-hooks",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"hooks",children:"Hooks"})}),"\n",(0,s.jsx)(n.h2,{id:"module-hooks",children:"Module Hooks"}),"\n",(0,s.jsx)(n.p,{children:"There are three ways to hook into module execution:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Direct hooks"})," - Override virtual lifecycle methods in ",(0,s.jsx)(n.code,{children:"Module<T>"})," (new in v4)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"IHookable interface"})," - Implement the interface for before/after execution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Module hooks class"})," - Register global hooks invoked for every module"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"direct-module-hooks-recommended",children:"Direct Module Hooks (Recommended)"}),"\n",(0,s.jsxs)(n.p,{children:["The simplest way to add lifecycle hooks is to override the virtual methods directly in your module. These hooks run ",(0,s.jsx)(n.strong,{children:"before"})," IHookable hooks and provide access to the full module context and result."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class MyModule : Module<string>\n{\n    // Called before ExecuteAsync - ideal for setup, validation, or logging\n    protected override Task OnBeforeExecuteAsync(IModuleContext context, CancellationToken cancellationToken)\n    {\n        context.Logger.LogInformation("Setting up MyModule...");\n        return Task.CompletedTask;\n    }\n\n    // Called after ExecuteAsync - can modify the result or add cleanup logic\n    protected override Task<ModuleResult<string>?> OnAfterExecuteAsync(\n        IModuleContext context,\n        ModuleResult<string> result,\n        CancellationToken cancellationToken)\n    {\n        context.Logger.LogInformation("MyModule completed with: {Result}", result.Value);\n        return Task.FromResult<ModuleResult<string>?>(null); // null = keep original result\n    }\n\n    // Called when the module is skipped (ShouldSkip returns true)\n    protected override Task OnSkippedAsync(\n        IModuleContext context,\n        SkipDecision skipDecision,\n        CancellationToken cancellationToken)\n    {\n        context.Logger.LogInformation("MyModule was skipped: {Reason}", skipDecision.Reason);\n        return Task.CompletedTask;\n    }\n\n    // Called when ExecuteAsync throws an exception (before OnAfterExecuteAsync)\n    protected override Task OnFailedAsync(\n        IModuleContext context,\n        Exception exception,\n        CancellationToken cancellationToken)\n    {\n        context.Logger.LogError(exception, "MyModule failed!");\n        // Send alert, cleanup resources, etc.\n        return Task.CompletedTask;\n    }\n\n    public override async Task<string?> ExecuteAsync(IModuleContext context, CancellationToken cancellationToken)\n    {\n        return "Hello, World!";\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Hook execution order:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OnBeforeExecuteAsync"})," (direct hook)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IHookable.OnBeforeExecute"})," (if implemented)"]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"ExecuteAsync"})}),"\n",(0,s.jsxs)(n.li,{children:["On failure: ",(0,s.jsx)(n.code,{children:"OnFailedAsync"})," (direct hook)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OnAfterExecuteAsync"})," (direct hook)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IHookable.OnAfterExecute"})," (in finally block)"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Error handling:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OnBeforeExecuteAsync"})," exceptions ",(0,s.jsx)(n.strong,{children:"prevent"})," execution and are propagated"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OnAfterExecuteAsync"})," exceptions are ",(0,s.jsx)(n.strong,{children:"logged"})," but don't affect the result"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OnSkippedAsync"})," exceptions are ",(0,s.jsx)(n.strong,{children:"logged"})," but don't affect skip behavior"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OnFailedAsync"})," exceptions are ",(0,s.jsx)(n.strong,{children:"logged"})," but don't prevent ",(0,s.jsx)(n.code,{children:"OnAfterExecuteAsync"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Edge case: OnBeforeExecuteAsync throws"}),"\nIf ",(0,s.jsx)(n.code,{children:"OnBeforeExecuteAsync"})," throws an exception:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ExecuteAsync"})," will NOT be called"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OnFailedAsync"})," will NOT be called (module never started)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OnAfterExecuteAsync"})," will NOT be called (before hooks didn't complete)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"IHookable.OnAfterExecute"})," WILL still be called (in finally block)"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"moduleconfiguration-hooks",children:"ModuleConfiguration Hooks"}),"\n",(0,s.jsxs)(n.p,{children:["You can also configure simple before/after hooks using ",(0,s.jsx)(n.code,{children:"ModuleConfiguration"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class MyModule : Module<string>\n{\n    protected override ModuleConfiguration Configure() => ModuleConfiguration.Create()\n        .WithBeforeExecute(ctx =>\n        {\n            ctx.Logger.LogInformation("MyModule starting!");\n            return Task.CompletedTask;\n        })\n        .WithAfterExecute(ctx =>\n        {\n            ctx.Logger.LogInformation("MyModule ended!");\n            return Task.CompletedTask;\n        })\n        .Build();\n\n    public override async Task<string?> ExecuteAsync(IModuleContext context, CancellationToken cancellationToken)\n    {\n        return "Done";\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This approach is useful when you want to combine hooks with other configuration like timeouts or retry policies:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"protected override ModuleConfiguration Configure() => ModuleConfiguration.Create()\n    .WithBeforeExecute(ctx => LogStartAsync(ctx))\n    .WithAfterExecute(ctx => LogEndAsync(ctx))\n    .WithTimeout(TimeSpan.FromMinutes(5))\n    .WithRetryCount(3)\n    .Build();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"hooks-class",children:"Hooks class"}),"\n",(0,s.jsx)(n.p,{children:"If we want to have repeat behaviour for every module, we can register some 'Hook' classes during startup."}),"\n",(0,s.jsx)(n.p,{children:"Pipeline Global Hooks will run once, before any modules have started, and/or after all modules have finished. Pipeline Module Hooks will run repeatedly, before every module, and/or after every module."}),"\n",(0,s.jsx)(n.p,{children:"This can be useful if you want some repeated action for every module. E.g. standard logging behaviour."}),"\n",(0,s.jsxs)(n.p,{children:["To do so, simply create a class that implements ",(0,s.jsx)(n.code,{children:"IPipelineModuleHooks"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"collection.AddPipelineModuleHooks<MyModuleHooks>();\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class MyModuleHooks : IPipelineModuleHooks\n{\n    public Task OnBeforeModuleStartAsync(IPipelineHookContext context, IModule module)\n    {\n        context.Logger.LogInformation("{Module} is starting", module.GetType().Name);\n        return Task.CompletedTask;\n    }\n\n    public Task OnBeforeModuleEndAsync(IPipelineHookContext context, IModule module)\n    {\n        context.Logger.LogInformation("{Module} finished after {Elapsed}", module.GetType().Name, module.Duration);\n        return Task.CompletedTask;\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"global-hooks",children:"Global Hooks"}),"\n",(0,s.jsxs)(n.p,{children:["Global hooks can be registered by creating a class that implements the ",(0,s.jsx)(n.code,{children:"IPipelineGlobalHooks"})," interface."]}),"\n",(0,s.jsx)(n.p,{children:"These are similar to the module hooks, but instead of running before and after EACH module, they run before and after ALL modules. So think of them more as a pipeline start up, and a pipeline finish hook."}),"\n",(0,s.jsx)(n.p,{children:"The end hook also gives you access to a Pipeline summary object. Giving you information such as pass/fail, duration, start and end, etc."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"collection.AddPipelineGlobalHooks<MyGlobalHooks>();\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'public class MyGlobalHooks : IPipelineGlobalHooks\n{\n    public Task OnStartAsync(IPipelineHookContext pipelineContext)\n    {\n        pipelineContext.Logger.LogInformation("Pipeline is starting");\n        return Task.CompletedTask;\n    }\n\n    public Task OnEndAsync(IPipelineHookContext pipelineContext, PipelineSummary pipelineSummary)\n    {\n        pipelineContext.Logger.LogInformation("Pipeline is ending");\n        return Task.CompletedTask;\n    }\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>r});var l=o(6540);const s={},t=l.createContext(s);function i(e){const n=l.useContext(t);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),l.createElement(t.Provider,{value:n},e.children)}}}]);