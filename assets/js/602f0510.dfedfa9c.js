"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[579],{4750:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"fundamentals","title":"Fundamentals","description":"Pipeline Host","source":"@site/docs/fundamentals.md","sourceDirName":".","slug":"/fundamentals","permalink":"/ModularPipelines/docs/fundamentals","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Fundamentals","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Modular Pipelines","permalink":"/ModularPipelines/docs/"},"next":{"title":"How-To","permalink":"/ModularPipelines/docs/category/how-to"}}');var s=t(4848),i=t(8453);const a={title:"Fundamentals",sidebar_position:1},l="Fundamentals",r={},c=[{value:"Pipeline Host",id:"pipeline-host",level:2},{value:"Modules",id:"modules",level:2},{value:"Strong Typing",id:"strong-typing",level:2},{value:"Custom Types",id:"custom-types",level:2},{value:"Optional Data",id:"optional-data",level:2},{value:"Automatic Parallelisation and Explicit Dependencies",id:"automatic-parallelisation-and-explicit-dependencies",level:2},{value:"Checking a Module&#39;s status",id:"checking-a-modules-status",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"fundamentals",children:"Fundamentals"})}),"\n",(0,s.jsx)(n.h2,{id:"pipeline-host",children:"Pipeline Host"}),"\n",(0,s.jsxs)(n.p,{children:["Your pipeline is hosted by a ",(0,s.jsx)(n.code,{children:"PipelineHost"}),". This is built off the back off the Microsoft Generic Host, meaning in-built ",(0,s.jsx)(n.code,{children:"IConfiguration"})," and dependency injection. Set up should feel familiar. To start you create a ",(0,s.jsx)(n.code,{children:"PipelineHostBuilder"})," object, register modules, then call ",(0,s.jsx)(n.code,{children:"ExecutePipelineAsync()"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"modules",children:"Modules"}),"\n",(0,s.jsx)(n.p,{children:"The building blocks of your pipelines are called Modules. Modules can be as big or as small as you decide, though it's recommended to make them as small as possible. That way we can speed up execution by utilizing parallelization and we are able to more clearly see what failed and where it failed."}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"a self-contained unit or item, such as an assembly of electronic components and associated wiring or a segment of computer software, which itself performs a defined task and can be linked with other such units to form a larger system"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Modules can retrieve other modules, and access information from them."}),"\n",(0,s.jsx)(n.h2,{id:"strong-typing",children:"Strong Typing"}),"\n",(0,s.jsx)(n.p,{children:"Modules are strongly typed, so we can return clear, concrete objects, and other modules have direct access to those strong objects, without any need for casting or guessing the type, or guessing keys from a dictionary."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var myModule = await GetModule<MyFirstModule>();\nvar string1 = myModule.Value!.MyFirstString;\nvar string2 = myModule.Value!.MySecondString;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"custom-types",children:"Custom Types"}),"\n",(0,s.jsxs)(n.p,{children:["A module isn't restricted to a pre-determined type either. You can pass the ",(0,s.jsx)(n.code,{children:"Type"})," of object that you want to return when you inherit from the base ",(0,s.jsx)(n.code,{children:"Module"})," class"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class MyModule : Module<MyCustomClass>\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class PingApiModule : Module<HttpResponseMessage>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You'll then be instructed by the compiler to make sure the return type of your main ",(0,s.jsx)(n.code,{children:"ExecuteAsync"})," method matches the ",(0,s.jsx)(n.code,{children:"Type"})," you've set up."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"protected override async Task<MyCustomClass?> ExecuteAsync(IPipelineContext context, CancellationToken cancellationToken)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"optional-data",children:"Optional Data"}),"\n",(0,s.jsxs)(n.p,{children:["You can choose not to set a ",(0,s.jsx)(n.code,{children:"Type"})," and the default will be an ",(0,s.jsx)(n.code,{children:"IDictionary<string, object>"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class MyModule : Module\n{\n    protected override async Task<IDictionary<string, object>?> ExecuteAsync(IPipelineContext context, CancellationToken cancellationToken)\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Returning an object isn't mandatory either. You can return ",(0,s.jsx)(n.code,{children:"null"})," or use the method ",(0,s.jsx)(n.code,{children:"NothingAsync();"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"automatic-parallelisation-and-explicit-dependencies",children:"Automatic Parallelisation and Explicit Dependencies"}),"\n",(0,s.jsx)(n.p,{children:"Modules will all try to run in parallel if possible. But if a Module depends on another Module, it is smart enough to automatically wait for the dependent module to finish before executing."}),"\n",(0,s.jsx)(n.p,{children:"Dependencies are configured by adding an attribute on your Module. This also makes it clear to navigate through your pipeline, as with your IDE/Intellisense, you can click through to other Modules with ease."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"[DependsOn<MyOtherModule>]\npublic class MyModule : Module\n"})}),"\n",(0,s.jsx)(n.h2,{id:"checking-a-modules-status",children:"Checking a Module's status"}),"\n",(0,s.jsx)(n.p,{children:"When you get another Module, you'll be passed an object that has the data you returned, as well as some information about its execution. So you can have logic in your pipeline for if another module was skipped for example."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var myModule = await GetModule<MyOptionalModule>();\n\nif (myModule.ModuleResultType == ModuleResultType.Skipped)\n{\n    return null;\n}\n\nreturn await DoSomethingAsync();\n"})}),"\n",(0,s.jsx)(n.p,{children:"or if a Module failed, but it was configured to not stop the pipeline, you could check its Exception."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var myModule = await GetModule<MyOptionalModule>();\n\nif (gitModule.Exception is ItemAlreadyExistsException)\n{\n    return null;\n}\n\nreturn await DoSomethingAsync();\n"})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var o=t(6540);const s={},i=o.createContext(s);function a(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);