"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[37],{6489:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>u,toc:()=>i});var s=l(4848),t=l(8453);const o={title:"Always Run"},r="Always Run",u={id:"how-to/always-run",title:"Always Run",description:"Module Run Types",source:"@site/docs/how-to/always-run.md",sourceDirName:"how-to",slug:"/how-to/always-run",permalink:"/ModularPipelines/docs/how-to/always-run",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Always Run"},sidebar:"tutorialSidebar",previous:{title:"Logging",permalink:"/ModularPipelines/docs/how-to/logging"},next:{title:"Analyzers",permalink:"/ModularPipelines/docs/how-to/analyzers"}},a={},i=[{value:"Module Run Types",id:"module-run-types",level:2},{value:"Example",id:"example",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"always-run",children:"Always Run"})}),"\n",(0,s.jsx)(n.h2,{id:"module-run-types",children:"Module Run Types"}),"\n",(0,s.jsx)(n.p,{children:"There are two module run types."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"AlwaysRun,"}),"\n",(0,s.jsx)(n.li,{children:"OnSuccessfulDependencies,"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["By default, modules use ",(0,s.jsx)(n.code,{children:"OnSuccessfulDependencies"}),". This means that if a module is dependent on another module, and that other module fails, then the module waiting will not start and will abort."]}),"\n",(0,s.jsxs)(n.p,{children:["If you switch to ",(0,s.jsx)(n.code,{children:"AlwaysRun"}),", then regardless of if any dependencies failed, the module will still run. This can be useful when you want to clean up resources, regardless of whether the pipeline passed or failed."]}),"\n",(0,s.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class MyModule : Module\n{\n    public override ModuleRunType ModuleRunType => ModuleRunType.AlwaysRun;\n\n    protected override Task<IDictionary<string, object>?> ExecuteAsync(IPipelineContext context, CancellationToken cancellationToken)\n    {\n        // Do something\n    }\n}\n"})})]})}function c(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,l)=>{l.d(n,{R:()=>r,x:()=>u});var s=l(6540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function u(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);