"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[2159],{3474:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>u,frontMatter:()=>t,metadata:()=>d,toc:()=>a});const d=JSON.parse('{"id":"how-to/execution-and-dependencies","title":"Execution and Dependencies","description":"The default behaviour is for modules to run in parallel, to speed up a pipeline as much as possible.","source":"@site/docs/how-to/execution-and-dependencies.md","sourceDirName":"how-to","slug":"/how-to/execution-and-dependencies","permalink":"/ModularPipelines/docs/how-to/execution-and-dependencies","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Execution and Dependencies","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Defining Modules","permalink":"/ModularPipelines/docs/how-to/defining-modules"},"next":{"title":"Sharing data across modules","permalink":"/ModularPipelines/docs/how-to/sharing-data"}}');var s=i(4848),o=i(8453);const t={title:"Execution and Dependencies",sidebar_position:3},l="Execution and Dependencies",r={},a=[{value:"Required vs Optional Dependencies",id:"required-vs-optional-dependencies",level:2},{value:"Auto-Registration",id:"auto-registration",level:3},{value:"Optional Dependencies",id:"optional-dependencies",level:2},{value:"Category Filters and Optional Dependencies",id:"category-filters-and-optional-dependencies",level:3},{value:"Accessing Dependency Results",id:"accessing-dependency-results",level:2},{value:"Programmatic Dependencies",id:"programmatic-dependencies",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"execution-and-dependencies",children:"Execution and Dependencies"})}),"\n",(0,s.jsx)(n.p,{children:"The default behaviour is for modules to run in parallel, to speed up a pipeline as much as possible."}),"\n",(0,s.jsxs)(n.p,{children:["If you don't want a particular module to start until another one has finished, then you simply add a ",(0,s.jsx)(n.code,{children:"[DependsOn<TModule>]"})," attribute to your module class."]}),"\n",(0,s.jsx)(n.p,{children:"These can chain together as appropriate. And it'll detect if two modules depend on each other."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"[DependsOn<Module1>] // or [DependsOn(typeof(Module1))] for older language versions\npublic class Module2 : Module\n{\n    ...\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"required-vs-optional-dependencies",children:"Required vs Optional Dependencies"}),"\n",(0,s.jsxs)(n.p,{children:["By default, dependencies declared with ",(0,s.jsx)(n.code,{children:"[DependsOn<T>]"})," are ",(0,s.jsx)(n.strong,{children:"required"}),". This means:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Auto-registration"}),": If the dependency module is not explicitly registered, ModularPipelines will automatically register it for you"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Validation"}),": The pipeline validates that all required dependencies can be resolved before execution"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"// Required dependency (default)\n// Module1 will be auto-registered if not explicitly added\n[DependsOn<Module1>]\npublic class Module2 : Module<string>\n{\n    protected override async Task<string?> ExecuteAsync(IModuleContext context, CancellationToken cancellationToken)\n    {\n        // Safe to call - Module1 is guaranteed to be registered\n        var result = await context.GetModule<Module1>();\n        return result.Value;\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"auto-registration",children:"Auto-Registration"}),"\n",(0,s.jsx)(n.p,{children:"When you declare a required dependency, you don't need to explicitly register it:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"await PipelineHostBuilder.Create()\n    .AddModule<Module2>()  // Module1 is auto-registered because Module2 depends on it\n    .ExecutePipelineAsync();\n"})}),"\n",(0,s.jsx)(n.p,{children:"This simplifies pipeline configuration and ensures all required dependencies are always present. Auto-registration also handles transitive dependencies - if Module1 depends on Module0, both will be auto-registered."}),"\n",(0,s.jsx)(n.h2,{id:"optional-dependencies",children:"Optional Dependencies"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"Optional = true"})," when a dependency may or may not be present:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'// Optional dependency - won\'t be auto-registered\n[DependsOn<Module1>(Optional = true)]\npublic class Module2 : Module<string>\n{\n    protected override async Task<string?> ExecuteAsync(IModuleContext context, CancellationToken cancellationToken)\n    {\n        // Use GetModuleIfRegistered for optional dependencies\n        var module1 = context.GetModuleIfRegistered<Module1>();\n\n        if (module1 != null)\n        {\n            var result = await module1;\n            return $"Got result: {result.Value}";\n        }\n\n        return "Module1 not available";\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Optional dependencies are useful when:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A module can work with or without another module's output"}),"\n",(0,s.jsx)(n.li,{children:"You're using category filters and some dependencies may be excluded"}),"\n",(0,s.jsx)(n.li,{children:"You want conditional behavior based on what modules are registered"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"category-filters-and-optional-dependencies",children:"Category Filters and Optional Dependencies"}),"\n",(0,s.jsxs)(n.p,{children:["When using ",(0,s.jsx)(n.code,{children:"RunOnlyCategories"})," to filter which modules run, dependencies in other categories may not execute. Mark such dependencies as optional:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:'[ModuleCategory("test")]\n[DependsOn<CompileModule>(Optional = true)]  // CompileModule is in "compile" category\npublic class TestModule : Module<string>\n{\n    protected override async Task<string?> ExecuteAsync(IModuleContext context, CancellationToken cancellationToken)\n    {\n        var compile = context.GetModuleIfRegistered<CompileModule>();\n\n        if (compile == null)\n        {\n            // CompileModule was filtered out - handle gracefully\n            return "Running tests without compile";\n        }\n\n        var result = await compile;\n        return result.IsSkipped\n            ? "Compile was skipped"\n            : $"Compile result: {result.Value}";\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"accessing-dependency-results",children:"Accessing Dependency Results"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"GetModule<T>()"})," for required dependencies - it throws if the module is not registered:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var result = await context.GetModule<Module1>();\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"GetModuleIfRegistered<T>()"})," for optional dependencies - it returns null if not registered:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"var module = context.GetModuleIfRegistered<Module1>();\nif (module != null)\n{\n    var result = await module;\n    // Use the result\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"programmatic-dependencies",children:"Programmatic Dependencies"}),"\n",(0,s.jsxs)(n.p,{children:["You can also declare dependencies programmatically by overriding ",(0,s.jsx)(n.code,{children:"DeclareDependencies"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csharp",children:"public class Module2 : Module<string>\n{\n    protected override void DeclareDependencies(IDependencyDeclaration deps)\n    {\n        deps.DependsOn<Module1>();                    // Required\n        deps.DependsOnOptional<Module3>();            // Optional\n        deps.DependsOnIf<Module4>(someCondition);     // Conditional\n    }\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>l});var d=i(6540);const s={},o=d.createContext(s);function t(e){const n=d.useContext(o);return d.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),d.createElement(o.Provider,{value:n},e.children)}}}]);