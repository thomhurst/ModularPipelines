"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[571],{8862:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>r,toc:()=>m});var i=n(4848),o=n(8453);const a={title:"Time Estimator"},s="Time Estimator",r={id:"how-to/time-estimator",title:"Time Estimator",description:"The time estimator is a class built by you, used to estimate times for modules for displaying in the console progress dialog. It isn't mandatory, but without it, estimated times will not be correct.",source:"@site/docs/how-to/time-estimator.md",sourceDirName:"how-to",slug:"/how-to/time-estimator",permalink:"/ModularPipelines/docs/how-to/time-estimator",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Time Estimator"},sidebar:"tutorialSidebar",previous:{title:"Sub-Modules",permalink:"/ModularPipelines/docs/how-to/sub-modules"},next:{title:"Timeouts",permalink:"/ModularPipelines/docs/how-to/timeouts"}},l={},m=[{value:"Example",id:"example",level:2}];function u(e){const t={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"time-estimator",children:"Time Estimator"}),"\n",(0,i.jsx)(t.p,{children:"The time estimator is a class built by you, used to estimate times for modules for displaying in the console progress dialog. It isn't mandatory, but without it, estimated times will not be correct."}),"\n",(0,i.jsx)(t.p,{children:"The idea is that on every run of a module, it takes note of how long it took to run, and then provides it to this class to save somewhere. That's up to you. A blob storage, a database, wherever."}),"\n",(0,i.jsx)(t.p,{children:"Then on subsequent runs, it'll ask you for an estimated time for a module. You go and pull this back out of your database or wherever, and then pass it back to the framework."}),"\n",(0,i.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:"await PipelineHostBuilder.Create()\n    .AddModule<Module1>()\n    .AddModule<Module2>()\n    .AddModule<Module3>()\n    .AddModuleEstimatedTimeProvider<MyEstimatedTimeProvider>()\n    .ExecutePipelineAsync();\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-csharp",children:'public class MyEstimatedTimeProvider : IModuleEstimatedTimeProvider\n{\n    private readonly string _directory = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),\n        "ModularPipelines", "EstimatedTimes");\n\n    public async Task<TimeSpan> GetModuleEstimatedTimeAsync(Type moduleType)\n    {\n        var fileName = $"{moduleType.FullName}.txt";\n        return await GetEstimatedTimeAsync(fileName);\n    }\n\n    public async Task SaveModuleTimeAsync(Type moduleType, TimeSpan duration)\n    {\n        var fileName = $"{moduleType.FullName}.txt";\n\n        await SaveModuleTimeAsync(duration, fileName);\n    }\n\n    public async Task<IEnumerable<SubModuleEstimation>> GetSubModuleEstimatedTimesAsync(Type moduleType)\n    {\n        var directoryInfo = new DirectoryInfo(_directory);\n\n        if (!directoryInfo.Exists)\n        {\n            directoryInfo.Create();\n        }\n\n        directoryInfo.Create();\n\n        var paths = directoryInfo\n            .EnumerateFiles("*.txt", SearchOption.TopDirectoryOnly)\n            .Where(x => x.Name.StartsWith($"Mod-{moduleType.FullName}"))\n            .ToList();\n\n        var subModuleEstimations = await paths.ToAsyncProcessorBuilder()\n            .SelectAsync(async file =>\n            {\n                try\n                {\n                    var name = Path.GetFileNameWithoutExtension(file.FullName).Split("-Sub-")[1];\n                    var time = await GetEstimatedTimeAsync(file.FullName);\n                    return new SubModuleEstimation(name, time);\n                }\n                catch\n                {\n                    File.Delete(file.FullName);\n                    return null;\n                }\n            })\n            .ProcessInParallel();\n\n        return subModuleEstimations.OfType<SubModuleEstimation>();\n    }\n\n    public async Task SaveSubModuleTimeAsync(Type moduleType, SubModuleEstimation subModuleEstimation)\n    {\n        var fileName = $"Mod-{moduleType.FullName}-Sub-{subModuleEstimation.SubModuleName}.txt";\n\n        await SaveModuleTimeAsync(subModuleEstimation.EstimatedDuration, fileName);\n    }\n\n    private async Task<TimeSpan> GetEstimatedTimeAsync(string fileName)\n    {\n        var path = Path.Combine(_directory, fileName);\n\n        if (File.Exists(path))\n        {\n            var contents = await File.ReadAllTextAsync(path);\n            return TimeSpan.Parse(contents);\n        }\n\n        // Some default fallback. We can\'t estimate for now so we\'ll estimate next time.\n        return TimeSpan.FromMinutes(2);\n    }\n\n    private async Task SaveModuleTimeAsync(TimeSpan duration, string fileName)\n    {\n        Directory.CreateDirectory(_directory);\n\n        var path = Path.Combine(_directory, fileName);\n\n        await File.WriteAllTextAsync(path, duration.ToString());\n    }\n}\n'})})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var i=n(6540);const o={},a=i.createContext(o);function s(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);