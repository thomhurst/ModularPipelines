"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[656],{9840:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"why","title":"Why Modular Pipelines?","description":"C# / .NET","source":"@site/docs/why.md","sourceDirName":".","slug":"/why","permalink":"/ModularPipelines/docs/why","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Fully Orchestrated Example","permalink":"/ModularPipelines/docs/examples/example"}}');var a=t(4848),o=t(8453);const r={sidebar_position:5},s="Why Modular Pipelines?",l={},d=[{value:"C# / .NET",id:"c--net",level:2},{value:"Source Control",id:"source-control",level:2},{value:"Running locally",id:"running-locally",level:2},{value:"Portability",id:"portability",level:2}];function u(e){const n={h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"why-modular-pipelines",children:"Why Modular Pipelines?"})}),"\n",(0,a.jsx)(n.h2,{id:"c--net",children:"C# / .NET"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"The .NET ecosystem is rich with features and libraries. You can utilize what already exists and not have to re-invent the wheel."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"If you're already a .NET developer, you don't have to concern yourself as much with the different features, languages or syntaxes of different build systems. No need for YAML-based pipeline definitions, Powershell scripts, bash scripts, or even just unfamiliar UI based build systems."}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"Strong typing - We can structure our modules with objects that we can pass around, and we know what data we then have available to use."}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"source-control",children:"Source Control"}),"\n",(0,a.jsx)(n.p,{children:"Some Pipelines, such as TeamCity, aren't typically source controlled. They're built from within the UI itself. This means that making changes for a new feature that isn't released yet has to happen globally, which can cause build breakages between different branches. With it in Source Control, we can change the pipeline on a branch for a new feature without affecting other builds and branches. This makes testing easier and doesn't degrade your production deployments."}),"\n",(0,a.jsx)(n.p,{children:"A broken pipeline shouldn't ever get merged into the main branch if it never went green. A pipeline change should be made via a pull request, and require a successful build in order to merge."}),"\n",(0,a.jsx)(n.p,{children:"We are able to easily look back at a history of changes if they're all stored in git commits"}),"\n",(0,a.jsx)(n.p,{children:"We are easily able to identify who made what changes"}),"\n",(0,a.jsx)(n.h2,{id:"running-locally",children:"Running locally"}),"\n",(0,a.jsx)(n.p,{children:"Many build systems, such as TeamCity and Azure DevOps require running pipelines on their remote agents, and then waiting for a result and parsing through the build output if anything went wrong. It can be very trial-and-error, with lots of lengthy re-runs when trying to debug something.\nBecause ModularPipelines is not tied to a specific build system, it can be run anywhere that has the .NET SDK installed. That includes your developer machine. So as long as you have adequate permissions, you can debug a pipeline locally on your machine. You get all the benefits of the .NET debugger, so we can view in-memory values, and access exceptions, etc. This makes for a much quicker feedback loop!"}),"\n",(0,a.jsx)(n.p,{children:"Because a pipeline can be run locally, there's nothing to stop you from creating a 'local developer pipeline'.\nHow many times have you started a new role or team, and been provided a huge developer setup guide that requires you to download and install numerous different things? You could define a pipeline for local machines. You can decide in startup, depending on something like the Environment name, and decide to either register modules for setting up a local developer machine, or if on a build agent, for deploying to the cloud."}),"\n",(0,a.jsx)(n.h2,{id:"portability",children:"Portability"}),"\n",(0,a.jsx)(n.p,{children:"Want to move to a different build system? You don't have to re-learn or setup the whole thing from scratch. Your system simply needs access to your Pipeline project and have the .NET SDK installed."})]})}function c(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var i=t(6540);const a={},o=i.createContext(a);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);