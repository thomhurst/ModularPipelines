"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[7793],{1858:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"how-to/migrating-to-v3","title":"Migrating to V3","description":"ModularPipelines V3 is a major release that modernizes the API to follow ASP.NET Core minimal API patterns. This guide covers all breaking changes and how to migrate your existing pipelines.","source":"@site/docs/how-to/migrating-to-v3.md","sourceDirName":"how-to","slug":"/how-to/migrating-to-v3","permalink":"/ModularPipelines/docs/how-to/migrating-to-v3","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":99,"frontMatter":{"title":"Migrating to V3","sidebar_position":99},"sidebar":"tutorialSidebar","previous":{"title":"Testing","permalink":"/ModularPipelines/docs/how-to/testing"},"next":{"title":"Always Run","permalink":"/ModularPipelines/docs/how-to/always-run"}}');var o=i(4848),l=i(8453);const r={title:"Migrating to V3",sidebar_position:99},s="Migrating from V2 to V3",d={},c=[{value:"Quick Migration Checklist",id:"quick-migration-checklist",level:2},{value:"Entry Point Changes",id:"entry-point-changes",level:2},{value:"Before (V2)",id:"before-v2",level:3},{value:"After (V3)",id:"after-v3",level:3},{value:"Key Differences",id:"key-differences",level:3},{value:"Compatibility Note",id:"compatibility-note",level:3},{value:"Module Behavior Changes",id:"module-behavior-changes",level:2},{value:"Before (V2)",id:"before-v2-1",level:3},{value:"After (V3)",id:"after-v3-1",level:3},{value:"Migration Mapping",id:"migration-mapping",level:3},{value:"Alternative: Lifecycle Hook Overrides",id:"alternative-lifecycle-hook-overrides",level:3},{value:"Context Parameter Change",id:"context-parameter-change",level:2},{value:"Before (V2)",id:"before-v2-2",level:3},{value:"After (V3)",id:"after-v3-2",level:3},{value:"Command Execution Options",id:"command-execution-options",level:2},{value:"Before (V2)",id:"before-v2-3",level:3},{value:"After (V3)",id:"after-v3-3",level:3},{value:"Migration Mapping",id:"migration-mapping-1",level:3},{value:"Benefits",id:"benefits",level:3},{value:"Command Logging Configuration",id:"command-logging-configuration",level:2},{value:"Before (V2)",id:"before-v2-4",level:3},{value:"After (V3)",id:"after-v3-4",level:3},{value:"Verbosity Levels",id:"verbosity-levels",level:3},{value:"Configuration Precedence",id:"configuration-precedence",level:3},{value:"Setting Global Defaults",id:"setting-global-defaults",level:3},{value:"Using Presets",id:"using-presets",level:3},{value:"Fine-Grained Control",id:"fine-grained-control",level:3},{value:"Output Manipulators",id:"output-manipulators",level:3},{value:"Migration Mapping",id:"migration-mapping-2",level:3},{value:"Getting Module Results",id:"getting-module-results",level:2},{value:"Before (V2)",id:"before-v2-5",level:3},{value:"After (V3)",id:"after-v3-5",level:3},{value:"Alternative Result Access Patterns",id:"alternative-result-access-patterns",level:3},{value:"Key Change Summary",id:"key-change-summary",level:3},{value:"Result Type Quick Reference",id:"result-type-quick-reference",level:3},{value:"Unchanged Features",id:"unchanged-features",level:2},{value:"Tool Options Classes Regenerated",id:"tool-options-classes-regenerated",level:2},{value:"Before (V2)",id:"before-v2-6",level:3},{value:"After (V3)",id:"after-v3-6",level:3},{value:"Finding the Right Property Names",id:"finding-the-right-property-names",level:3},{value:"Shell and Command Execution",id:"shell-and-command-execution",level:2},{value:"Before (V2)",id:"before-v2-7",level:3},{value:"After (V3)",id:"after-v3-7",level:3},{value:"Shell Context Structure",id:"shell-context-structure",level:3},{value:"Git and Tool Command Signatures",id:"git-and-tool-command-signatures",level:2},{value:"Before (V2)",id:"before-v2-8",level:3},{value:"After (V3)",id:"after-v3-8",level:3},{value:"Note on Parameter Names",id:"note-on-parameter-names",level:3},{value:"Async Configuration Methods",id:"async-configuration-methods",level:2},{value:"Deleted Types and Members",id:"deleted-types-and-members",level:2},{value:"New Features in V3",id:"new-features-in-v3",level:2},{value:"Non-Generic Module Classes",id:"non-generic-module-classes",level:3},{value:"Pipeline Validation",id:"pipeline-validation",level:3},{value:"Dynamic Dependencies",id:"dynamic-dependencies",level:3},{value:"New Dependency Attributes",id:"new-dependency-attributes",level:3},{value:"Conditional Execution Attributes",id:"conditional-execution-attributes",level:3},{value:"Module Tags",id:"module-tags",level:3},{value:"Plugin System",id:"plugin-system",level:3},{value:"Complete Migration Example",id:"complete-migration-example",level:2},{value:"Before (V2)",id:"before-v2-9",level:3},{value:"After (V3)",id:"after-v3-9",level:3},{value:"Breaking API Reference",id:"breaking-api-reference",level:2},{value:"LLM/AI Migration Reference",id:"llmai-migration-reference",level:2},{value:"Complete API Transformation Map",id:"complete-api-transformation-map",level:3},{value:"Common Compiler Errors and Fixes",id:"common-compiler-errors-and-fixes",level:3},{value:"Regex Patterns for Automated Migration",id:"regex-patterns-for-automated-migration",level:3},{value:"V3 Module Template",id:"v3-module-template",level:3},{value:"V3 Result Handling Patterns",id:"v3-result-handling-patterns",level:3},{value:"V3 Command Execution Pattern",id:"v3-command-execution-pattern",level:3},{value:"Keywords for Search",id:"keywords-for-search",level:3},{value:"Getting Help",id:"getting-help",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"migrating-from-v2-to-v3",children:"Migrating from V2 to V3"})}),"\n",(0,o.jsx)(n.p,{children:"ModularPipelines V3 is a major release that modernizes the API to follow ASP.NET Core minimal API patterns. This guide covers all breaking changes and how to migrate your existing pipelines."}),"\n",(0,o.jsx)(n.h2,{id:"quick-migration-checklist",children:"Quick Migration Checklist"}),"\n",(0,o.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Replace ",(0,o.jsx)(n.code,{children:"PipelineHostBuilder.Create()"})," with ",(0,o.jsx)(n.code,{children:"Pipeline.CreateBuilder(args)"})]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Replace callback-based configuration with direct property access"]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Change ",(0,o.jsx)(n.code,{children:"IPipelineContext"})," to ",(0,o.jsx)(n.code,{children:"IModuleContext"})," in ",(0,o.jsx)(n.code,{children:"ExecuteAsync"})," signatures"]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Update ",(0,o.jsx)(n.code,{children:"GetModule<T>()"})," calls to ",(0,o.jsx)(n.code,{children:"context.GetModule<T>()"})," (method moved to context)"]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Migrate virtual property overrides to ",(0,o.jsx)(n.code,{children:"Configure()"})," builder"]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Update result access patterns to use pattern matching or ",(0,o.jsx)(n.code,{children:"ValueOrDefault"})]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Move ",(0,o.jsx)(n.code,{children:"WorkingDirectory"}),", ",(0,o.jsx)(n.code,{children:"EnvironmentVariables"}),", etc. from tool options to ",(0,o.jsx)(n.code,{children:"CommandExecutionOptions"})]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Migrate ",(0,o.jsx)(n.code,{children:"LogInput"}),"/",(0,o.jsx)(n.code,{children:"LogOutput"})," to ",(0,o.jsx)(n.code,{children:"CommandLoggingOptions"})," with ",(0,o.jsx)(n.code,{children:"CommandLogVerbosity"})]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Update ",(0,o.jsx)(n.code,{children:"context.Command"})," to ",(0,o.jsx)(n.code,{children:"context.Shell.Command"})]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Replace tool options constructors with property initializers (e.g., ",(0,o.jsx)(n.code,{children:'new DotNetNewOptions { TemplateShortName = "x" }'}),")"]}),"\n",(0,o.jsxs)(n.li,{className:"task-list-item",children:[(0,o.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Add ",(0,o.jsx)(n.code,{children:"token:"})," named parameter when calling tool commands without ",(0,o.jsx)(n.code,{children:"CommandExecutionOptions"})]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"entry-point-changes",children:"Entry Point Changes"}),"\n",(0,o.jsx)(n.p,{children:"The pipeline entry point has been completely redesigned to match ASP.NET Core's minimal API pattern."}),"\n",(0,o.jsx)(n.h3,{id:"before-v2",children:"Before (V2)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'await PipelineHostBuilder.Create()\n    .ConfigureAppConfiguration((context, builder) =>\n    {\n        builder.AddJsonFile("appsettings.json")\n            .AddUserSecrets<Program>()\n            .AddEnvironmentVariables();\n    })\n    .ConfigureServices((context, collection) =>\n    {\n        collection.Configure<MySettings>(context.Configuration.GetSection("MySettings"));\n\n        if (context.HostingEnvironment.IsDevelopment())\n        {\n            collection.AddModule<DevModule>();\n        }\n\n        collection.AddModule<BuildModule>();\n    })\n    .ConfigurePipelineOptions((context, options) =>\n    {\n        options.ExecutionMode = ExecutionMode.StopOnFirstException;\n    })\n    .AddModule<TestModule>()\n    .AddModule<DeployModule>()\n    .ExecutePipelineAsync();\n'})}),"\n",(0,o.jsx)(n.h3,{id:"after-v3",children:"After (V3)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'var builder = Pipeline.CreateBuilder(args);\n\n// Direct property access instead of callbacks\nbuilder.Configuration\n    .AddJsonFile("appsettings.json")\n    .AddUserSecrets<Program>()\n    .AddEnvironmentVariables();\n\n// Configure services directly\nbuilder.Services.Configure<MySettings>(builder.Configuration.GetSection("MySettings"));\n\nif (builder.Environment.IsDevelopment())\n{\n    builder.Services.AddModule<DevModule>();\n}\n\nbuilder.Services\n    .AddModule<BuildModule>()\n    .AddModule<TestModule>()\n    .AddModule<DeployModule>();\n\n// Configure options directly\nbuilder.Options.ExecutionMode = ExecutionMode.StopOnFirstException;\n\n// Two-step build and run\nawait builder.Build().RunAsync();\n'})}),"\n",(0,o.jsx)(n.h3,{id:"key-differences",children:"Key Differences"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"V2"}),(0,o.jsx)(n.th,{children:"V3"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"PipelineHostBuilder.Create()"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Pipeline.CreateBuilder(args)"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:".ConfigureAppConfiguration((ctx, builder) => ...)"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"builder.Configuration.Add...()"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:".ConfigureServices((ctx, collection) => ...)"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"builder.Services.Add...()"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:".ConfigurePipelineOptions((ctx, options) => ...)"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"builder.Options.Property = value"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:".AddModule<T>()"})," on builder"]}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"builder.Services.AddModule<T>()"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:".ExecutePipelineAsync()"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:".Build().RunAsync()"})})]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"compatibility-note",children:"Compatibility Note"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"ExecutePipelineAsync()"})," extension method still exists for simpler migrations:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"// This still works in V3\nawait builder.ExecutePipelineAsync();\n"})}),"\n",(0,o.jsx)(n.h2,{id:"module-behavior-changes",children:"Module Behavior Changes"}),"\n",(0,o.jsxs)(n.p,{children:["V2 used virtual property and method overrides to configure module behavior. V3 consolidates these into a fluent ",(0,o.jsx)(n.code,{children:"Configure()"})," builder."]}),"\n",(0,o.jsx)(n.h3,{id:"before-v2-1",children:"Before (V2)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'public class MyModule : Module<string>\n{\n    // Timeout override\n    protected internal override TimeSpan Timeout => TimeSpan.FromMinutes(5);\n\n    // Retry policy override\n    protected override AsyncRetryPolicy<string?> RetryPolicy =>\n        Policy<string?>.Handle<Exception>()\n            .WaitAndRetryAsync(3, i => TimeSpan.FromSeconds(i * i));\n\n    // Skip logic override\n    protected internal override Task<SkipDecision> ShouldSkip(IPipelineContext context)\n    {\n        if (context.Git().Information.BranchName != "main")\n            return Task.FromResult(SkipDecision.Skip("Only runs on main branch"));\n        return Task.FromResult(SkipDecision.DoNotSkip);\n    }\n\n    // Ignore failures override\n    protected internal override Task<bool> ShouldIgnoreFailures(\n        IPipelineContext context, Exception exception) => Task.FromResult(true);\n\n    // Always run override\n    public override ModuleRunType ModuleRunType => ModuleRunType.AlwaysRun;\n\n    // Lifecycle hooks\n    protected internal override Task OnBeforeExecute(IPipelineContext context)\n    {\n        // Pre-execution logic\n        return Task.CompletedTask;\n    }\n\n    protected internal override Task OnAfterExecute(IPipelineContext context)\n    {\n        // Post-execution logic\n        return Task.CompletedTask;\n    }\n\n    protected override async Task<string?> ExecuteAsync(\n        IPipelineContext context, CancellationToken cancellationToken)\n    {\n        // Module logic\n        return "result";\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"after-v3-1",children:"After (V3)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'public class MyModule : Module<string>\n{\n    protected override ModuleConfiguration Configure() => ModuleConfiguration.Create()\n        .WithTimeout(TimeSpan.FromMinutes(5))\n        .WithRetryCount(3)\n        .WithSkipWhen(ctx => ctx.Git().Information.BranchName != "main"\n            ? SkipDecision.Skip("Only runs on main branch")\n            : SkipDecision.DoNotSkip)\n        .WithIgnoreFailures()\n        .WithAlwaysRun()\n        .WithBeforeExecute(ctx => LogStartAsync(ctx))\n        .WithAfterExecute(ctx => LogEndAsync(ctx))\n        .Build();\n\n    protected override async Task<string?> ExecuteAsync(\n        IModuleContext context, CancellationToken cancellationToken)\n    {\n        // Module logic\n        return "result";\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"migration-mapping",children:"Migration Mapping"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"V2 Override"}),(0,o.jsx)(n.th,{children:"V3 Configure() Method"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"TimeSpan Timeout"})," property"]}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:".WithTimeout(TimeSpan)"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"AsyncRetryPolicy<T?> RetryPolicy"})," property"]}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:".WithRetryCount(int)"})," or ",(0,o.jsx)(n.code,{children:".WithRetryPolicy(IAsyncPolicy)"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"Task<SkipDecision> ShouldSkip()"})," method"]}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:".WithSkipWhen(...)"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"Task<bool> ShouldIgnoreFailures()"})," method"]}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:".WithIgnoreFailures()"})," or ",(0,o.jsx)(n.code,{children:".WithIgnoreFailuresWhen(...)"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"ModuleRunType.AlwaysRun"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:".WithAlwaysRun()"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"Task OnBeforeExecute()"})," method"]}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:".WithBeforeExecute(...)"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"Task OnAfterExecute()"})," method"]}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:".WithAfterExecute(...)"})})]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"alternative-lifecycle-hook-overrides",children:"Alternative: Lifecycle Hook Overrides"}),"\n",(0,o.jsx)(n.p,{children:"V3 also supports lifecycle hooks as overridable methods on the module class:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'public class MyModule : Module<string>\n{\n    protected override Task OnBeforeExecuteAsync(\n        IModuleContext context, CancellationToken cancellationToken)\n    {\n        // Runs before ExecuteAsync\n        return Task.CompletedTask;\n    }\n\n    protected override Task OnAfterExecuteAsync(\n        IModuleContext context,\n        ModuleResult<string> result,\n        CancellationToken cancellationToken)\n    {\n        // Runs after ExecuteAsync (success or failure)\n        return Task.FromResult<ModuleResult<string>?>(null);\n    }\n\n    protected override Task OnSkippedAsync(\n        IModuleContext context,\n        SkipDecision skipDecision,\n        CancellationToken cancellationToken)\n    {\n        // Runs when module is skipped\n        return Task.CompletedTask;\n    }\n\n    protected override Task OnFailedAsync(\n        IModuleContext context,\n        Exception exception,\n        CancellationToken cancellationToken)\n    {\n        // Runs when module fails (before OnAfterExecuteAsync)\n        return Task.CompletedTask;\n    }\n\n    protected override async Task<string?> ExecuteAsync(\n        IModuleContext context, CancellationToken cancellationToken)\n    {\n        return "result";\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"context-parameter-change",children:"Context Parameter Change"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"ExecuteAsync"})," method now receives ",(0,o.jsx)(n.code,{children:"IModuleContext"})," instead of ",(0,o.jsx)(n.code,{children:"IPipelineContext"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"before-v2-2",children:"Before (V2)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"protected override async Task<string?> ExecuteAsync(\n    IPipelineContext context, CancellationToken cancellationToken)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"after-v3-2",children:"After (V3)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"protected override async Task<string?> ExecuteAsync(\n    IModuleContext context, CancellationToken cancellationToken)\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"IModuleContext"})," extends the pipeline context with module-specific capabilities like ",(0,o.jsx)(n.code,{children:"GetModule<TModule>()"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"command-execution-options",children:"Command Execution Options"}),"\n",(0,o.jsxs)(n.p,{children:["Execution-related properties have been separated from tool-specific options into a dedicated ",(0,o.jsx)(n.code,{children:"CommandExecutionOptions"}),' class. This provides cleaner separation between "what to run" and "how to run it".']}),"\n",(0,o.jsx)(n.h3,{id:"before-v2-3",children:"Before (V2)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Execution options were mixed with tool options\nawait context.DotNet().Build(new DotNetBuildOptions\n{\n    Project = "MySolution.sln",\n    Configuration = Configuration.Release,\n    WorkingDirectory = "/path/to/project",        // Was on tool options\n    EnvironmentVariables = new Dictionary<string, string?>\n    {\n        ["CI"] = "true"\n    },\n    ThrowOnNonZeroExitCode = false\n});\n'})}),"\n",(0,o.jsx)(n.h3,{id:"after-v3-3",children:"After (V3)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Tool options only contain tool-specific arguments\nawait context.DotNet().Build(\n    new DotNetBuildOptions\n    {\n        ProjectSolution = "MySolution.sln",\n        Configuration = Configuration.Release,\n    },\n    new CommandExecutionOptions                    // Execution options are separate\n    {\n        WorkingDirectory = "/path/to/project",\n        EnvironmentVariables = new Dictionary<string, string?>\n        {\n            ["CI"] = "true"\n        },\n        ThrowOnNonZeroExitCode = false\n    });\n'})}),"\n",(0,o.jsx)(n.h3,{id:"migration-mapping-1",children:"Migration Mapping"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"V2 (on tool options)"}),(0,o.jsxs)(n.th,{children:["V3 (on ",(0,o.jsx)(n.code,{children:"CommandExecutionOptions"}),")"]})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"WorkingDirectory"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"WorkingDirectory"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"EnvironmentVariables"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"EnvironmentVariables"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"ThrowOnNonZeroExitCode"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"ThrowOnNonZeroExitCode"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CommandLineCredentials"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CommandLineCredentials"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"LoggingSettings"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"LogSettings"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"InputLoggingManipulator"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"InputLoggingManipulator"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"OutputLoggingManipulator"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"OutputLoggingManipulator"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"N/A"}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"ExecutionTimeout"})," (new)"]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"N/A"}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"GracefulShutdownTimeout"})," (new)"]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"N/A"}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"Sudo"})," (new)"]})]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"benefits",children:"Benefits"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Cleaner API"}),": Tool options focus only on tool-specific arguments"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Reusability"}),": Share ",(0,o.jsx)(n.code,{children:"CommandExecutionOptions"})," across multiple commands"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"New features"}),": ",(0,o.jsx)(n.code,{children:"ExecutionTimeout"}),", ",(0,o.jsx)(n.code,{children:"GracefulShutdownTimeout"}),", and ",(0,o.jsx)(n.code,{children:"Sudo"})," options"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"command-logging-configuration",children:"Command Logging Configuration"}),"\n",(0,o.jsxs)(n.p,{children:["V3 introduces a new ",(0,o.jsx)(n.code,{children:"CommandLoggingOptions"})," system that replaces the previous logging configuration. The new system provides verbosity levels and fine-grained control over what gets logged."]}),"\n",(0,o.jsx)(n.h3,{id:"before-v2-4",children:"Before (V2)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"// Logging settings were on tool options with limited control\nawait context.DotNet().Build(new DotNetBuildOptions\n{\n    LogInput = true,\n    LogOutput = false,\n    // Limited options available\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"after-v3-4",children:"After (V3)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Rich logging configuration via CommandLoggingOptions\nawait context.DotNet().Build(\n    new DotNetBuildOptions { Configuration = "Release" },\n    new CommandExecutionOptions\n    {\n        LogSettings = new CommandLoggingOptions\n        {\n            Verbosity = CommandLogVerbosity.Detailed,\n            ShowCommandArguments = true,\n            ShowStandardOutput = true,\n            ShowStandardError = true,\n            ShowExitCode = true,\n            ShowExecutionTime = true\n        }\n    });\n'})}),"\n",(0,o.jsx)(n.h3,{id:"verbosity-levels",children:"Verbosity Levels"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Level"}),(0,o.jsx)(n.th,{children:"Description"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Silent"})}),(0,o.jsx)(n.td,{children:"No output at all"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Minimal"})}),(0,o.jsx)(n.td,{children:"Only command input (no output/errors)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Normal"})}),(0,o.jsx)(n.td,{children:"Input, output, and errors on failure (default)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Detailed"})}),(0,o.jsx)(n.td,{children:"Above plus exit code and duration"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Diagnostic"})}),(0,o.jsx)(n.td,{children:"Everything including working directory and timestamps"})]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"configuration-precedence",children:"Configuration Precedence"}),"\n",(0,o.jsx)(n.p,{children:"V3 uses a three-tier configuration system (highest to lowest priority):"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Per-Call"}),": ",(0,o.jsx)(n.code,{children:"CommandExecutionOptions.LogSettings"})," on individual command calls"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Global Default"}),": ",(0,o.jsx)(n.code,{children:"PipelineOptions.DefaultLoggingOptions"})," set at pipeline level"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"System Default"}),": ",(0,o.jsx)(n.code,{children:"CommandLoggingOptions.Default"})," (Normal verbosity)"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"setting-global-defaults",children:"Setting Global Defaults"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"var builder = Pipeline.CreateBuilder(args);\n\n// Set global default for all commands\nbuilder.Options.DefaultLoggingOptions = new CommandLoggingOptions\n{\n    Verbosity = CommandLogVerbosity.Minimal\n};\n\n// Or use presets\nbuilder.Options.DefaultLoggingOptions = CommandLoggingOptions.Silent;\nbuilder.Options.DefaultLoggingOptions = CommandLoggingOptions.Diagnostic;\n\nawait builder.Build().RunAsync();\n"})}),"\n",(0,o.jsx)(n.h3,{id:"using-presets",children:"Using Presets"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"// Silent - no command logging at all\nnew CommandExecutionOptions { LogSettings = CommandLoggingOptions.Silent }\n\n// Diagnostic - maximum verbosity for debugging\nnew CommandExecutionOptions { LogSettings = CommandLoggingOptions.Diagnostic }\n\n// Default - normal verbosity\nnew CommandExecutionOptions { LogSettings = CommandLoggingOptions.Default }\n"})}),"\n",(0,o.jsx)(n.h3,{id:"fine-grained-control",children:"Fine-Grained Control"}),"\n",(0,o.jsx)(n.p,{children:"Override individual settings regardless of verbosity level:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"new CommandLoggingOptions\n{\n    Verbosity = CommandLogVerbosity.Normal,\n    ShowCommandArguments = true,\n    ShowStandardOutput = true,\n    ShowStandardError = true,\n    ShowExitCode = true,           // Show even at Normal verbosity\n    ShowExecutionTime = true,      // Show even at Normal verbosity\n    ShowWorkingDirectory = false,\n    IncludeTimestamps = false\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"output-manipulators",children:"Output Manipulators"}),"\n",(0,o.jsx)(n.p,{children:"Transform logged content before it's written:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'new CommandExecutionOptions\n{\n    LogSettings = new CommandLoggingOptions { Verbosity = CommandLogVerbosity.Normal },\n    InputLoggingManipulator = input => input.Length > 100\n        ? input.Substring(0, 100) + "..."\n        : input,\n    OutputLoggingManipulator = output => output.Replace("secret-value", "***")\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"migration-mapping-2",children:"Migration Mapping"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"V2"}),(0,o.jsx)(n.th,{children:"V3"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"LogInput = true/false"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"ShowCommandArguments = true/false"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"LogOutput = true/false"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"ShowStandardOutput = true/false"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"InputLoggingManipulator"})," on tool options"]}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"InputLoggingManipulator"})," on ",(0,o.jsx)(n.code,{children:"CommandExecutionOptions"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"OutputLoggingManipulator"})," on tool options"]}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"OutputLoggingManipulator"})," on ",(0,o.jsx)(n.code,{children:"CommandExecutionOptions"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"N/A"}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"Verbosity"})," levels (Silent, Minimal, Normal, Detailed, Diagnostic)"]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"N/A"}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"ShowExitCode"}),", ",(0,o.jsx)(n.code,{children:"ShowExecutionTime"}),", ",(0,o.jsx)(n.code,{children:"ShowWorkingDirectory"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"N/A"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"IncludeTimestamps"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"N/A"}),(0,o.jsxs)(n.td,{children:["Global defaults via ",(0,o.jsx)(n.code,{children:"PipelineOptions.DefaultLoggingOptions"})]})]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"getting-module-results",children:"Getting Module Results"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"GetModule"})," method has moved from the module base class to the context. The result access patterns have also changed to use a discriminated union."]}),"\n",(0,o.jsx)(n.h3,{id:"before-v2-5",children:"Before (V2)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'[DependsOn<BuildModule>]\npublic class DeployModule : Module<DeployResult>\n{\n    protected override async Task<DeployResult?> ExecuteAsync(\n        IPipelineContext context, CancellationToken cancellationToken)\n    {\n        // Method on module base class\n        var buildResult = await GetModule<BuildModule>();\n\n        // Direct value access\n        var artifact = buildResult.Value!.ArtifactPath;\n\n        // Enum-based status check\n        if (buildResult.ModuleResultType == ModuleResultType.Skipped)\n        {\n            return null;\n        }\n\n        if (buildResult.ModuleResultType == ModuleResultType.Failure)\n        {\n            throw new Exception("Build failed", buildResult.Exception);\n        }\n\n        return await Deploy(artifact);\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"after-v3-5",children:"After (V3)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'[DependsOn<BuildModule>]\npublic class DeployModule : Module<DeployResult>\n{\n    protected override async Task<DeployResult?> ExecuteAsync(\n        IModuleContext context, CancellationToken cancellationToken)\n    {\n        // Method moved to context\n        var buildResult = await context.GetModule<BuildModule>();\n\n        // Option 1: Pattern matching (recommended)\n        return buildResult switch\n        {\n            ModuleResult<BuildOutput>.Success { Value: var output }\n                => await Deploy(output.ArtifactPath),\n            ModuleResult.Skipped { Decision: var skip }\n                => null,\n            ModuleResult.Failure { Exception: var ex }\n                => throw new InvalidOperationException("Build failed", ex),\n            _ => throw new InvalidOperationException("Unexpected result type")\n        };\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"alternative-result-access-patterns",children:"Alternative Result Access Patterns"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'var buildResult = await context.GetModule<BuildModule>();\n\n// Option 1: Pattern matching (recommended - handles all cases)\nreturn buildResult switch\n{\n    ModuleResult<BuildOutput>.Success { Value: var output } => Process(output),\n    ModuleResult.Skipped => null,\n    ModuleResult.Failure { Exception: var ex } => throw ex,\n    _ => null\n};\n\n// Option 2: Match helper method (functional style)\nreturn buildResult.Match(\n    onSuccess: output => Process(output),\n    onFailure: ex => throw new InvalidOperationException("Failed", ex),\n    onSkipped: skip => null\n);\n\n// Option 3: Safe accessor (simplest migration path)\nvar artifact = buildResult.ValueOrDefault?.ArtifactPath;\nif (artifact == null) return null;\nreturn await Deploy(artifact);\n\n// Option 4: Quick status checks\nif (buildResult.IsSuccess)\n{\n    var value = buildResult.ValueOrDefault;\n}\nif (buildResult.IsFailure)\n{\n    var ex = buildResult.ExceptionOrDefault;\n}\nif (buildResult.IsSkipped)\n{\n    var reason = buildResult.SkipDecisionOrDefault?.Reason;\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"key-change-summary",children:"Key Change Summary"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"V2"}),(0,o.jsx)(n.th,{children:"V3"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"await GetModule<T>()"})," (on module)"]}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"await context.GetModule<T>()"})," (on context)"]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"result.Value"})}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"result.ValueOrDefault"})," or pattern match"]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"result.Exception"})}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"result.ExceptionOrDefault"})," or pattern match"]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"result.ModuleResultType == ModuleResultType.X"})}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"result.IsSuccess"}),", ",(0,o.jsx)(n.code,{children:"result.IsFailure"}),", ",(0,o.jsx)(n.code,{children:"result.IsSkipped"})]})]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"result-type-quick-reference",children:"Result Type Quick Reference"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Check"}),(0,o.jsx)(n.th,{children:"V2"}),(0,o.jsx)(n.th,{children:"V3"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Is success?"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"result.ModuleResultType == ModuleResultType.Success"})}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"result.IsSuccess"})," or ",(0,o.jsx)(n.code,{children:"result is ModuleResult<T>.Success"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Is failure?"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"result.ModuleResultType == ModuleResultType.Failure"})}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"result.IsFailure"})," or ",(0,o.jsx)(n.code,{children:"result is ModuleResult.Failure"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Is skipped?"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"result.ModuleResultType == ModuleResultType.Skipped"})}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"result.IsSkipped"})," or ",(0,o.jsx)(n.code,{children:"result is ModuleResult.Skipped"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Get value"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"result.Value"})}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"result.ValueOrDefault"})," or pattern match"]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Get exception"}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"result.Exception"})}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"result.ExceptionOrDefault"})," or pattern match"]})]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"unchanged-features",children:"Unchanged Features"}),"\n",(0,o.jsx)(n.p,{children:"The following features work the same in V3 as they did in V2:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Sub-Modules"}),": Both ",(0,o.jsx)(n.code,{children:"context.SubModule<T>(name, action)"})," (returns value) and ",(0,o.jsx)(n.code,{children:"context.SubModule(name, action)"})," (no return) are fully supported. Use sub-modules to track iterations within a module (e.g., packing multiple NuGet packages). See ",(0,o.jsx)(n.a,{href:"/docs/how-to/sub-modules",children:"Sub-Modules documentation"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Hooks"}),": Global pipeline hooks via ",(0,o.jsx)(n.code,{children:"IHook<T>"})," interfaces remain unchanged"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Requirements"}),": ",(0,o.jsx)(n.code,{children:"IPipelineRequirement"})," for validating prerequisites"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Secrets"}),": Secret registration and obfuscation via ",(0,o.jsx)(n.code,{children:"AddSecret()"})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Categories and Tags"}),": Module organization with ",(0,o.jsx)(n.code,{children:"[ModuleCategory]"})," and ",(0,o.jsx)(n.code,{children:"[ModuleTag]"})]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"tool-options-classes-regenerated",children:"Tool Options Classes Regenerated"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Important"}),": All tool options classes (DotNet, Git, Docker, Azure, etc.) have been regenerated using CLI scraping. This means:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"No constructors"}),": Options classes no longer accept constructor arguments. Use property initializers instead."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Properties may have changed"}),": Some properties may have been renamed, removed, or added based on current CLI help output."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Use property initializers"}),": Always use object initializer syntax."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"before-v2-6",children:"Before (V2)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Constructor arguments - NO LONGER WORKS\nvar newOptions = new DotNetNewOptions("console");\nvar packOptions = new DotNetPackOptions(projectPath);\nvar pushOptions = new DotNetNugetPushOptions(packagePath);\n'})}),"\n",(0,o.jsx)(n.h3,{id:"after-v3-6",children:"After (V3)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Use property initializers instead\nvar newOptions = new DotNetNewOptions { TemplateShortName = "console" };\nvar packOptions = new DotNetPackOptions { TargetPath = projectPath };\nvar pushOptions = new DotNetNugetPushOptions { PackagePath = packagePath };\n'})}),"\n",(0,o.jsx)(n.h3,{id:"finding-the-right-property-names",children:"Finding the Right Property Names"}),"\n",(0,o.jsx)(n.p,{children:"If you're unsure which property to use:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"IntelliSense"}),": Type ",(0,o.jsx)(n.code,{children:"new DotNetXxxOptions { }"})," and explore available properties"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Source code"}),": Options are in ",(0,o.jsx)(n.code,{children:"ModularPipelines.<Tool>/Options/"})," directories"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"CLI help"}),": Property names typically match CLI flag names (e.g., ",(0,o.jsx)(n.code,{children:"--output"})," \u2192 ",(0,o.jsx)(n.code,{children:"Output"}),")"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"shell-and-command-execution",children:"Shell and Command Execution"}),"\n",(0,o.jsxs)(n.p,{children:["The command execution API has moved from ",(0,o.jsx)(n.code,{children:"context.Command"})," to ",(0,o.jsx)(n.code,{children:"context.Shell.Command"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"before-v2-7",children:"Before (V2)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'await context.Command.ExecuteCommandLineTool(new CommandLineToolOptions("mytool")\n{\n    Arguments = new[] { "arg1", "arg2" }\n});\n'})}),"\n",(0,o.jsx)(n.h3,{id:"after-v3-7",children:"After (V3)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'await context.Shell.Command.ExecuteCommandLineTool(\n    new CommandLineToolOptions("mytool")\n    {\n        Arguments = new[] { "arg1", "arg2" }\n    },\n    new CommandExecutionOptions\n    {\n        WorkingDirectory = "/path/to/dir"\n    });\n'})}),"\n",(0,o.jsx)(n.h3,{id:"shell-context-structure",children:"Shell Context Structure"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"context.Shell.Command    // General CLI tool execution (ICommand)\ncontext.Shell.Bash       // Bash script execution\ncontext.Shell.PowerShell // PowerShell script execution\n"})}),"\n",(0,o.jsx)(n.h2,{id:"git-and-tool-command-signatures",children:"Git and Tool Command Signatures"}),"\n",(0,o.jsxs)(n.p,{children:["All tool commands (Git, DotNet, Docker, etc.) now accept an optional ",(0,o.jsx)(n.code,{children:"CommandExecutionOptions"})," parameter. This is ",(0,o.jsx)(n.strong,{children:"optional"})," - you don't need to provide it if using defaults."]}),"\n",(0,o.jsx)(n.h3,{id:"before-v2-8",children:"Before (V2)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'await context.Git().Tag(new GitTagOptions\n{\n    TagName = "v1.0.0",\n    Message = "Release v1.0.0"\n}, cancellationToken);\n'})}),"\n",(0,o.jsx)(n.h3,{id:"after-v3-8",children:"After (V3)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Without execution options (most common)\nawait context.Git().Tag(new GitTagOptions\n{\n    TagName = "v1.0.0",\n    Message = "Release v1.0.0"\n}, token: cancellationToken);\n\n// With execution options (when needed)\nawait context.Git().Tag(\n    new GitTagOptions\n    {\n        TagName = "v1.0.0",\n        Message = "Release v1.0.0"\n    },\n    new CommandExecutionOptions { WorkingDirectory = repoPath },\n    cancellationToken);\n'})}),"\n",(0,o.jsx)(n.h3,{id:"note-on-parameter-names",children:"Note on Parameter Names"}),"\n",(0,o.jsxs)(n.p,{children:["When calling without ",(0,o.jsx)(n.code,{children:"CommandExecutionOptions"}),", use named parameter ",(0,o.jsx)(n.code,{children:"token:"})," for the cancellation token to avoid ambiguity:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"// Correct - named parameter\nawait context.Git().Push(options, token: cancellationToken);\n\n// May be ambiguous without named parameter\nawait context.Git().Push(options, cancellationToken); // Could fail\n"})}),"\n",(0,o.jsx)(n.h2,{id:"async-configuration-methods",children:"Async Configuration Methods"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"WithSkipWhen"})," and ",(0,o.jsx)(n.code,{children:"WithIgnoreFailuresWhen"})," methods accept both sync and async lambdas. There are ",(0,o.jsxs)(n.strong,{children:["no separate ",(0,o.jsx)(n.code,{children:"Async"})," versions"]})," - the same method handles both:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Sync lambda\n.WithSkipWhen(() => someCondition)\n\n// Async lambda - same method name\n.WithSkipWhen(async () => await CheckConditionAsync())\n\n// With context - sync\n.WithSkipWhen(ctx => ctx.Git().Information.BranchName != "main")\n\n// With context - async\n.WithSkipWhen(async ctx => await ctx.SomeAsyncCheck())\n\n// Returning SkipDecision\n.WithSkipWhen(ctx => ctx.Git().Information.BranchName != "main"\n    ? SkipDecision.Skip("Not main branch")\n    : SkipDecision.DoNotSkip)\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The same applies to ",(0,o.jsx)(n.code,{children:"WithIgnoreFailuresWhen"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"// Sync\n.WithIgnoreFailuresWhen((ctx, ex) => ex is TimeoutException)\n\n// Async\n.WithIgnoreFailuresWhen(async (ctx, ex) => await ShouldIgnoreAsync(ex))\n"})}),"\n",(0,o.jsx)(n.h2,{id:"deleted-types-and-members",children:"Deleted Types and Members"}),"\n",(0,o.jsx)(n.p,{children:"The following have been removed in V3:"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Removed"}),(0,o.jsx)(n.th,{children:"Replacement"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"PipelineHostBuilder"})," class"]}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"Pipeline.CreateBuilder()"})," returns ",(0,o.jsx)(n.code,{children:"PipelineBuilder"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"ModuleBase"})," class"]}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"Module<T>"})," (simplified hierarchy)"]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"ModuleBase<T>"})," class"]}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Module<T>"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"ShouldSkip()"})," method"]}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Configure().WithSkipWhen()"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"ShouldIgnoreFailures()"})," method"]}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Configure().WithIgnoreFailures()"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"ModuleRunType"})," property"]}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Configure().WithAlwaysRun()"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"Timeout"})," property"]}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Configure().WithTimeout()"})})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"RetryPolicy"})," property"]}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"Configure().WithRetryCount()"})," or ",(0,o.jsx)(n.code,{children:".WithRetryPolicy()"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"GetModule<T>()"})," on module"]}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"context.GetModule<TModule>()"})})]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"new-features-in-v3",children:"New Features in V3"}),"\n",(0,o.jsx)(n.h3,{id:"non-generic-module-classes",children:"Non-Generic Module Classes"}),"\n",(0,o.jsxs)(n.p,{children:["V3 introduces non-generic ",(0,o.jsx)(n.code,{children:"Module"})," and ",(0,o.jsx)(n.code,{children:"SyncModule"})," base classes for modules that perform actions without returning meaningful data. These use the ",(0,o.jsx)(n.code,{children:"None"})," struct internally to represent the absence of a value."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"// Async module that doesn't return data\npublic class DeployModule : Module\n{\n    protected override async Task ExecuteModuleAsync(\n        IModuleContext context, CancellationToken cancellationToken)\n    {\n        await context.Shell.Command.ExecuteCommandLineTool(...);\n        // No return statement needed\n    }\n}\n\n// Sync module that doesn't return data\npublic class LoggingModule : SyncModule\n{\n    protected override void ExecuteModule(\n        IModuleContext context, CancellationToken cancellationToken)\n    {\n        context.Logger.LogInformation(\"Pipeline executed at {Time}\", DateTime.UtcNow);\n        // No return statement needed\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"None"}),' struct represents "nothing" and is semantically equivalent to ',(0,o.jsx)(n.code,{children:"null"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"None value = None.Value;\nvalue.Equals(null);     // true - None equals null\nvalue == default;       // true\nNone? nullable = null;\nnullable == value;      // true - None? and None are always equal\n"})}),"\n",(0,o.jsx)(n.h3,{id:"pipeline-validation",children:"Pipeline Validation"}),"\n",(0,o.jsx)(n.p,{children:"V3 introduces a validation API to catch configuration errors before execution:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'var builder = Pipeline.CreateBuilder(args);\nbuilder.Services.AddModule<MyModule>();\n\n// Option 1: Validate without running\nvar validation = await builder.ValidateAsync();\nif (validation.HasErrors)\n{\n    foreach (var error in validation.Errors)\n    {\n        Console.WriteLine($"[{error.Category}] {error.Message}");\n    }\n    Environment.Exit(1);\n}\n\n// Option 2: BuildAsync validates and throws on error\ntry\n{\n    var pipeline = await builder.BuildAsync();\n    await pipeline.RunAsync();\n}\ncatch (PipelineValidationException ex)\n{\n    foreach (var error in ex.ValidationResult.Errors)\n    {\n        Console.WriteLine($"[{error.Category}] {error.Message}");\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"dynamic-dependencies",children:"Dynamic Dependencies"}),"\n",(0,o.jsx)(n.p,{children:"Declare dependencies programmatically at runtime:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"public class MyModule : Module<string>\n{\n    protected override void DeclareDependencies(IDependencyDeclaration deps)\n    {\n        // Always depend on this module\n        deps.DependsOn<RequiredModule>();\n\n        // Optional dependency (won't fail if not registered)\n        deps.DependsOnOptional<OptionalModule>();\n\n        // Conditional dependency\n        deps.DependsOnIf<ProductionModule>(Environment.IsProduction);\n\n        // Lazy dependency (evaluated later)\n        deps.DependsOnLazy<HeavyModule>();\n    }\n\n    protected override async Task<string?> ExecuteAsync(\n        IModuleContext context, CancellationToken cancellationToken)\n    {\n        // ...\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"new-dependency-attributes",children:"New Dependency Attributes"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Depend on all modules in a category\n[DependsOnModulesInCategory("Build")]\npublic class TestModule : Module<TestResults> { }\n\n// Depend on all modules with a specific tag\n[DependsOnModulesWithTag("database")]\npublic class MigrationModule : Module<bool> { }\n\n// Depend on all modules with a specific attribute\n[DependsOnModulesWithAttribute(typeof(CriticalAttribute))]\npublic class ValidationModule : Module<bool> { }\n'})}),"\n",(0,o.jsx)(n.h3,{id:"conditional-execution-attributes",children:"Conditional Execution Attributes"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"// Run only on specific platforms\n[RunOnWindows]\npublic class WindowsModule : Module<string> { }\n\n[RunOnLinux]\npublic class LinuxModule : Module<string> { }\n\n[RunOnMacOS]\npublic class MacModule : Module<string> { }\n\n// Run ONLY on specific platform (skip on others)\n[RunOnWindowsOnly]\npublic class WindowsOnlyModule : Module<string> { }\n\n// Skip based on custom condition\n[SkipIf(typeof(IsNotMainBranchCondition))]\npublic class MainBranchModule : Module<string> { }\n\n// Combine conditions\n[RunIfAll(typeof(IsCI), typeof(IsMainBranch))]\npublic class CIMainModule : Module<string> { }\n\n[RunIfAny(typeof(IsCI), typeof(ForceRun))]\npublic class FlexibleModule : Module<string> { }\n"})}),"\n",(0,o.jsx)(n.h3,{id:"module-tags",children:"Module Tags"}),"\n",(0,o.jsx)(n.p,{children:"Tag modules for organization and dependency management:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Via attributes\n[ModuleTag("critical")]\n[ModuleTag("deployment")]\n[ModuleCategory("Infrastructure")]\npublic class DeployModule : Module<DeployResult> { }\n\n// Via property override\npublic class MyModule : Module<string>\n{\n    public override IReadOnlySet<string> Tags => new HashSet<string> { "critical", "fast" };\n    public override string? Category => "Build";\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"plugin-system",children:"Plugin System"}),"\n",(0,o.jsx)(n.p,{children:"Create reusable pipeline extensions:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'public class MyPlugin : IModularPipelinesPlugin\n{\n    public string Name => "MyPlugin";\n    public int Priority => 0; // Lower runs first\n\n    public void ConfigureServices(IServiceCollection services)\n    {\n        services.AddSingleton<IMyService, MyService>();\n    }\n\n    public void ConfigurePipeline(PipelineBuilder builder)\n    {\n        builder.Services.AddModule<PluginModule>();\n        builder.Options.PrintLogo = false;\n    }\n}\n\n// Register plugin via attribute on assembly\n[assembly: ModularPipelinesPlugin(typeof(MyPlugin))]\n'})}),"\n",(0,o.jsx)(n.h2,{id:"complete-migration-example",children:"Complete Migration Example"}),"\n",(0,o.jsx)(n.h3,{id:"before-v2-9",children:"Before (V2)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Program.cs\nawait PipelineHostBuilder.Create()\n    .ConfigureAppConfiguration((ctx, builder) =>\n    {\n        builder.AddJsonFile("appsettings.json");\n    })\n    .ConfigureServices((ctx, services) =>\n    {\n        services.AddModule<BuildModule>()\n            .AddModule<TestModule>()\n            .AddModule<DeployModule>();\n    })\n    .ExecutePipelineAsync();\n\n// BuildModule.cs\npublic class BuildModule : Module<BuildOutput>\n{\n    protected internal override TimeSpan Timeout => TimeSpan.FromMinutes(10);\n\n    protected override async Task<BuildOutput?> ExecuteAsync(\n        IPipelineContext context, CancellationToken cancellationToken)\n    {\n        var result = await context.DotNet().Build(new DotNetBuildOptions());\n        return new BuildOutput(result.StandardOutput);\n    }\n}\n\n// DeployModule.cs\n[DependsOn<BuildModule>]\n[DependsOn<TestModule>]\npublic class DeployModule : Module<bool>\n{\n    protected internal override Task<SkipDecision> ShouldSkip(IPipelineContext context)\n    {\n        if (context.Git().Information.BranchName != "main")\n            return Task.FromResult(SkipDecision.Skip("Not main branch"));\n        return Task.FromResult(SkipDecision.DoNotSkip);\n    }\n\n    protected override async Task<bool> ExecuteAsync(\n        IPipelineContext context, CancellationToken cancellationToken)\n    {\n        var buildResult = await GetModule<BuildModule>();\n\n        if (buildResult.ModuleResultType != ModuleResultType.Success)\n            return false;\n\n        // Deploy using buildResult.Value\n        return true;\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"after-v3-9",children:"After (V3)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Program.cs\nvar builder = Pipeline.CreateBuilder(args);\n\nbuilder.Configuration.AddJsonFile("appsettings.json");\n\nbuilder.Services\n    .AddModule<BuildModule>()\n    .AddModule<TestModule>()\n    .AddModule<DeployModule>();\n\nawait builder.Build().RunAsync();\n\n// BuildModule.cs\npublic class BuildModule : Module<BuildOutput>\n{\n    protected override ModuleConfiguration Configure() => ModuleConfiguration.Create()\n        .WithTimeout(TimeSpan.FromMinutes(10))\n        .Build();\n\n    protected override async Task<BuildOutput?> ExecuteAsync(\n        IModuleContext context, CancellationToken cancellationToken)\n    {\n        var result = await context.DotNet().Build(new DotNetBuildOptions());\n        return new BuildOutput(result.StandardOutput);\n    }\n}\n\n// DeployModule.cs\n[DependsOn<BuildModule>]\n[DependsOn<TestModule>]\npublic class DeployModule : Module<bool>\n{\n    protected override ModuleConfiguration Configure() => ModuleConfiguration.Create()\n        .WithSkipWhen(ctx => ctx.Git().Information.BranchName != "main"\n            ? SkipDecision.Skip("Not main branch")\n            : SkipDecision.DoNotSkip)\n        .Build();\n\n    protected override async Task<bool> ExecuteAsync(\n        IModuleContext context, CancellationToken cancellationToken)\n    {\n        var buildResult = await context.GetModule<BuildModule>();\n\n        if (buildResult is not ModuleResult<BuildOutput>.Success { Value: var output })\n            return false;\n\n        // Deploy using output\n        return true;\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"breaking-api-reference",children:"Breaking API Reference"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"V2 API"}),(0,o.jsx)(n.th,{children:"V3 API"}),(0,o.jsx)(n.th,{children:"Notes"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"PipelineHostBuilder.Create()"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Pipeline.CreateBuilder(args)"})}),(0,o.jsx)(n.td,{children:"Pass command-line args"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:".ExecutePipelineAsync()"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:".Build().RunAsync()"})}),(0,o.jsx)(n.td,{children:"Two-step, or use extension"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:".ConfigureAppConfiguration(...)"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"builder.Configuration"})}),(0,o.jsx)(n.td,{children:"Direct access"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:".ConfigureServices(...)"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"builder.Services"})}),(0,o.jsx)(n.td,{children:"Direct access"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:".ConfigurePipelineOptions(...)"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"builder.Options"})}),(0,o.jsx)(n.td,{children:"Direct access"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"IPipelineContext"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"IModuleContext"})}),(0,o.jsx)(n.td,{children:"In ExecuteAsync signature"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"GetModule<T>()"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"context.GetModule<T>()"})}),(0,o.jsx)(n.td,{children:"Method moved to context"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"result.Value"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"result.ValueOrDefault"})}),(0,o.jsx)(n.td,{children:"Or use pattern matching"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"result.ModuleResultType"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"result.IsSuccess/IsFailure/IsSkipped"})}),(0,o.jsx)(n.td,{children:"Or pattern match"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"ShouldSkip()"})," override"]}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Configure().WithSkipWhen()"})}),(0,o.jsx)(n.td,{children:"Fluent builder"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"ShouldIgnoreFailures()"})," override"]}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Configure().WithIgnoreFailures()"})}),(0,o.jsx)(n.td,{children:"Fluent builder"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"Timeout"})," property override"]}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Configure().WithTimeout()"})}),(0,o.jsx)(n.td,{children:"Fluent builder"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"RetryPolicy"})," property override"]}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Configure().WithRetryCount()"})}),(0,o.jsx)(n.td,{children:"Fluent builder"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"ModuleRunType"})," override"]}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"Configure().WithAlwaysRun()"})}),(0,o.jsx)(n.td,{children:"Fluent builder"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"OnBeforeExecute()"})," override"]}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"Configure().WithBeforeExecute()"})," or ",(0,o.jsx)(n.code,{children:"OnBeforeExecuteAsync()"})]}),(0,o.jsx)(n.td,{children:"Either approach"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"OnAfterExecute()"})," override"]}),(0,o.jsxs)(n.td,{children:[(0,o.jsx)(n.code,{children:"Configure().WithAfterExecute()"})," or ",(0,o.jsx)(n.code,{children:"OnAfterExecuteAsync()"})]}),(0,o.jsx)(n.td,{children:"Either approach"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"options.WorkingDirectory"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CommandExecutionOptions.WorkingDirectory"})}),(0,o.jsx)(n.td,{children:"Separate parameter"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"options.EnvironmentVariables"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CommandExecutionOptions.EnvironmentVariables"})}),(0,o.jsx)(n.td,{children:"Separate parameter"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"options.ThrowOnNonZeroExitCode"})}),(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CommandExecutionOptions.ThrowOnNonZeroExitCode"})}),(0,o.jsx)(n.td,{children:"Separate parameter"})]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"llmai-migration-reference",children:"LLM/AI Migration Reference"}),"\n",(0,o.jsx)(n.p,{children:"This section provides structured data optimized for AI assistants helping with code migration."}),"\n",(0,o.jsx)(n.h3,{id:"complete-api-transformation-map",children:"Complete API Transformation Map"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:'# Entry Point Changes\n- old: "PipelineHostBuilder.Create()"\n  new: "Pipeline.CreateBuilder(args)"\n\n- old: ".ExecutePipelineAsync()"\n  new: ".Build().RunAsync()"\n\n- old: ".ConfigureAppConfiguration((context, builder) => { ... })"\n  new: "builder.Configuration.Add...()"\n\n- old: ".ConfigureServices((context, collection) => { ... })"\n  new: "builder.Services.Add...()"\n\n- old: ".ConfigurePipelineOptions((context, options) => { ... })"\n  new: "builder.Options.PropertyName = value"\n\n# Context Parameter\n- old: "IPipelineContext context"\n  new: "IModuleContext context"\n  scope: "ExecuteAsync method signature"\n\n# Module Result Access\n- old: "await GetModule<TModule>()"\n  new: "await context.GetModule<TModule>()"\n\n- old: "result.Value"\n  new: "result.ValueOrDefault"\n\n- old: "result.Exception"\n  new: "result.ExceptionOrDefault"\n\n- old: "result.ModuleResultType == ModuleResultType.Success"\n  new: "result.IsSuccess"\n\n- old: "result.ModuleResultType == ModuleResultType.Failure"\n  new: "result.IsFailure"\n\n- old: "result.ModuleResultType == ModuleResultType.Skipped"\n  new: "result.IsSkipped"\n\n# Module Configuration (property overrides \u2192 fluent builder)\n- old: "protected internal override TimeSpan Timeout => ..."\n  new: "Configure().WithTimeout(TimeSpan)"\n\n- old: "protected override AsyncRetryPolicy<T?> RetryPolicy => ..."\n  new: "Configure().WithRetryCount(int)"\n\n- old: "protected internal override Task<SkipDecision> ShouldSkip(...)"\n  new: "Configure().WithSkipWhen(Func<IModuleContext, SkipDecision>)"\n\n- old: "protected internal override Task<bool> ShouldIgnoreFailures(...)"\n  new: "Configure().WithIgnoreFailures()"\n\n- old: "public override ModuleRunType ModuleRunType => ModuleRunType.AlwaysRun"\n  new: "Configure().WithAlwaysRun()"\n\n- old: "protected internal override Task OnBeforeExecute(IPipelineContext context)"\n  new: "Configure().WithBeforeExecute(...) or OnBeforeExecuteAsync(...)"\n\n- old: "protected internal override Task OnAfterExecute(IPipelineContext context)"\n  new: "Configure().WithAfterExecute(...) or OnAfterExecuteAsync(...)"\n\n# Command Execution Options (moved from tool options to separate parameter)\n- old: "new DotNetBuildOptions { WorkingDirectory = path }"\n  new: "new DotNetBuildOptions { }, new CommandExecutionOptions { WorkingDirectory = path }"\n\n- old: "new DotNetBuildOptions { EnvironmentVariables = dict }"\n  new: "new DotNetBuildOptions { }, new CommandExecutionOptions { EnvironmentVariables = dict }"\n\n- old: "new DotNetBuildOptions { ThrowOnNonZeroExitCode = false }"\n  new: "new DotNetBuildOptions { }, new CommandExecutionOptions { ThrowOnNonZeroExitCode = false }"\n\n# Command Logging (new system in V3)\n- old: "new DotNetBuildOptions { LogInput = true, LogOutput = false }"\n  new: "new CommandExecutionOptions { LogSettings = new CommandLoggingOptions { ShowCommandArguments = true, ShowStandardOutput = false } }"\n\n- old: "InputLoggingManipulator on tool options"\n  new: "InputLoggingManipulator on CommandExecutionOptions"\n\n- old: "OutputLoggingManipulator on tool options"\n  new: "OutputLoggingManipulator on CommandExecutionOptions"\n\n- new_only: "CommandLogVerbosity.Silent/Minimal/Normal/Detailed/Diagnostic"\n  note: "Use verbosity levels for quick configuration"\n\n- new_only: "builder.Options.DefaultLoggingOptions = CommandLoggingOptions.Silent"\n  note: "Set global defaults at pipeline level"\n\n- new_only: "CommandLoggingOptions.Silent / .Diagnostic / .Default presets"\n  note: "Pre-configured logging options"\n\n# Shell/Command Execution (API restructured)\n- old: "context.Command.ExecuteCommandLineTool(...)"\n  new: "context.Shell.Command.ExecuteCommandLineTool(...)"\n\n- old: "context.Bash.ExecuteCommand(...)"\n  new: "context.Shell.Bash.ExecuteCommand(...)"\n\n- old: "context.Powershell.ExecuteCommand(...)"\n  new: "context.Shell.PowerShell.ExecuteCommand(...)"\n\n# Tool Options Constructors (removed - use property initializers)\n- old: "new DotNetNewOptions(\\"console\\")"\n  new: "new DotNetNewOptions { TemplateShortName = \\"console\\" }"\n  note: "All tool options constructors removed - use property initializers"\n\n- old: "new DotNetPackOptions(projectPath)"\n  new: "new DotNetPackOptions { TargetPath = projectPath }"\n\n- old: "new GitTagOptions(\\"v1.0.0\\")"\n  new: "new GitTagOptions { TagName = \\"v1.0.0\\" }"\n\n# Async Configuration (no separate Async methods)\n- old: "WithSkipWhenAsync(async () => ...)"\n  new: "WithSkipWhen(async () => ...)"\n  note: "Same method accepts both sync and async lambdas"\n\n- old: "WithIgnoreFailuresWhenAsync(...)"\n  new: "WithIgnoreFailuresWhen(...)"\n  note: "Same method accepts both sync and async lambdas"\n\n# Non-generic modules (V3 addition)\n- old: "public class MyModule : Module<IDictionary<string, object>>"\n  new: "public class MyModule : Module"\n  note: "For modules that don\'t return data"\n\n- old: "protected override async Task<IDictionary<string, object>?> ExecuteAsync(...)"\n  new: "protected override async Task ExecuteModuleAsync(...)"\n  note: "No return statement needed"\n'})}),"\n",(0,o.jsx)(n.h3,{id:"common-compiler-errors-and-fixes",children:"Common Compiler Errors and Fixes"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Error"}),(0,o.jsx)(n.th,{children:"Cause"}),(0,o.jsx)(n.th,{children:"Fix"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CS0246: 'PipelineHostBuilder' could not be found"})}),(0,o.jsx)(n.td,{children:"Class renamed"}),(0,o.jsxs)(n.td,{children:["Change to ",(0,o.jsx)(n.code,{children:"Pipeline.CreateBuilder(args)"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CS0246: 'IPipelineContext' could not be found"})}),(0,o.jsx)(n.td,{children:"Interface renamed"}),(0,o.jsxs)(n.td,{children:["Change to ",(0,o.jsx)(n.code,{children:"IModuleContext"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CS1061: 'Module' does not contain 'GetModule'"})}),(0,o.jsx)(n.td,{children:"Method moved"}),(0,o.jsxs)(n.td,{children:["Change ",(0,o.jsx)(n.code,{children:"GetModule<T>()"})," to ",(0,o.jsx)(n.code,{children:"context.GetModule<T>()"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CS0117: 'ModuleResult' does not contain 'Value'"})}),(0,o.jsx)(n.td,{children:"Property renamed"}),(0,o.jsxs)(n.td,{children:["Change ",(0,o.jsx)(n.code,{children:".Value"})," to ",(0,o.jsx)(n.code,{children:".ValueOrDefault"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CS0117: 'ModuleResult' does not contain 'Exception'"})}),(0,o.jsx)(n.td,{children:"Property renamed"}),(0,o.jsxs)(n.td,{children:["Change ",(0,o.jsx)(n.code,{children:".Exception"})," to ",(0,o.jsx)(n.code,{children:".ExceptionOrDefault"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CS0115: 'ShouldSkip': no suitable method found to override"})}),(0,o.jsx)(n.td,{children:"Method removed"}),(0,o.jsxs)(n.td,{children:["Use ",(0,o.jsx)(n.code,{children:"Configure().WithSkipWhen()"})," instead"]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CS0115: 'Timeout': no suitable method found to override"})}),(0,o.jsx)(n.td,{children:"Property removed"}),(0,o.jsxs)(n.td,{children:["Use ",(0,o.jsx)(n.code,{children:"Configure().WithTimeout()"})," instead"]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CS0115: 'RetryPolicy': no suitable method found to override"})}),(0,o.jsx)(n.td,{children:"Property removed"}),(0,o.jsxs)(n.td,{children:["Use ",(0,o.jsx)(n.code,{children:"Configure().WithRetryCount()"})," instead"]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CS1061: 'DotNetBuildOptions' does not contain 'WorkingDirectory'"})}),(0,o.jsx)(n.td,{children:"Property moved"}),(0,o.jsxs)(n.td,{children:["Pass ",(0,o.jsx)(n.code,{children:"CommandExecutionOptions"})," as second parameter"]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CS1061: 'DotNetBuildOptions' does not contain 'LogInput'"})}),(0,o.jsx)(n.td,{children:"Property moved"}),(0,o.jsxs)(n.td,{children:["Use ",(0,o.jsx)(n.code,{children:"CommandExecutionOptions.LogSettings"})," with ",(0,o.jsx)(n.code,{children:"CommandLoggingOptions"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CS0246: 'CommandLoggingOptions' could not be found"})}),(0,o.jsx)(n.td,{children:"Missing using"}),(0,o.jsxs)(n.td,{children:["Add ",(0,o.jsx)(n.code,{children:"using ModularPipelines.Options;"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CS1729: 'DotNetNewOptions' does not contain a constructor that takes 1 arguments"})}),(0,o.jsx)(n.td,{children:"Constructors removed"}),(0,o.jsxs)(n.td,{children:["Use property initializer: ",(0,o.jsx)(n.code,{children:'new DotNetNewOptions { TemplateShortName = "template" }'})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CS1061: 'IModuleContext' does not contain 'Command'"})}),(0,o.jsx)(n.td,{children:"API restructured"}),(0,o.jsxs)(n.td,{children:["Use ",(0,o.jsx)(n.code,{children:"context.Shell.Command.ExecuteCommandLineTool()"})]})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"CS0117: 'SkipDecision' does not contain 'WithSkipWhenAsync'"})}),(0,o.jsx)(n.td,{children:"No async version"}),(0,o.jsxs)(n.td,{children:["Use ",(0,o.jsx)(n.code,{children:"WithSkipWhen()"})," with async lambda: ",(0,o.jsx)(n.code,{children:".WithSkipWhen(async () => await CheckAsync())"})]})]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"regex-patterns-for-automated-migration",children:"Regex Patterns for Automated Migration"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-regex",children:"# Entry point\ns/PipelineHostBuilder\\.Create\\(\\)/Pipeline.CreateBuilder(args)/g\n\n# Context parameter in ExecuteAsync\ns/IPipelineContext\\s+context/IModuleContext context/g\n\n# GetModule calls\ns/await\\s+GetModule<(\\w+)>\\(\\)/await context.GetModule<$1>()/g\ns/GetModule<(\\w+)>\\(\\)/context.GetModule<$1>()/g\n\n# Result property access\ns/\\.Value(?![a-zA-Z])/\\.ValueOrDefault/g\ns/\\.Exception(?![a-zA-Z])/\\.ExceptionOrDefault/g\n\n# Result type checks\ns/\\.ModuleResultType\\s*==\\s*ModuleResultType\\.Success/\\.IsSuccess/g\ns/\\.ModuleResultType\\s*==\\s*ModuleResultType\\.Failure/\\.IsFailure/g\ns/\\.ModuleResultType\\s*==\\s*ModuleResultType\\.Skipped/\\.IsSkipped/g\n"})}),"\n",(0,o.jsx)(n.h3,{id:"v3-module-template",children:"V3 Module Template"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"// Async module WITH return value\npublic class MyModule : Module<MyResult>\n{\n    protected override ModuleConfiguration Configure() => ModuleConfiguration.Create()\n        .WithTimeout(TimeSpan.FromMinutes(5))\n        // Add other configuration as needed\n        .Build();\n\n    protected override async Task<MyResult?> ExecuteAsync(\n        IModuleContext context, CancellationToken cancellationToken)\n    {\n        // Implementation\n        return new MyResult();\n    }\n}\n\n// Async module WITHOUT return value\npublic class MyActionModule : Module\n{\n    protected override async Task ExecuteModuleAsync(\n        IModuleContext context, CancellationToken cancellationToken)\n    {\n        // Implementation - no return needed\n    }\n}\n\n// Sync module WITHOUT return value\npublic class MySyncModule : SyncModule\n{\n    protected override void ExecuteModule(\n        IModuleContext context, CancellationToken cancellationToken)\n    {\n        // Implementation - no return needed\n    }\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"v3-result-handling-patterns",children:"V3 Result Handling Patterns"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:"// Pattern 1: Pattern matching (recommended)\nvar result = await context.GetModule<BuildModule>();\nreturn result switch\n{\n    ModuleResult<BuildOutput>.Success { Value: var output } => Process(output),\n    ModuleResult.Skipped => null,\n    ModuleResult.Failure { Exception: var ex } => throw ex,\n    _ => null\n};\n\n// Pattern 2: Match helper\nvar result = await context.GetModule<BuildModule>();\nreturn result.Match(\n    onSuccess: output => Process(output),\n    onFailure: ex => throw ex,\n    onSkipped: skip => null\n);\n\n// Pattern 3: Simple property access (easiest migration)\nvar result = await context.GetModule<BuildModule>();\nif (result.IsSuccess)\n{\n    var value = result.ValueOrDefault;\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"v3-command-execution-pattern",children:"V3 Command Execution Pattern"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-csharp",children:'// Tool-specific options separate from execution options\nawait context.DotNet().Build(\n    new DotNetBuildOptions\n    {\n        ProjectSolution = "MySolution.sln",\n        Configuration = "Release",\n    },\n    new CommandExecutionOptions\n    {\n        WorkingDirectory = "/path/to/project",\n        EnvironmentVariables = new Dictionary<string, string?>\n        {\n            ["CI"] = "true"\n        },\n        ThrowOnNonZeroExitCode = false,\n        ExecutionTimeout = TimeSpan.FromMinutes(10)\n    });\n'})}),"\n",(0,o.jsx)(n.h3,{id:"keywords-for-search",children:"Keywords for Search"}),"\n",(0,o.jsx)(n.p,{children:"ModularPipelines, V3 migration, PipelineHostBuilder, Pipeline.CreateBuilder, IPipelineContext, IModuleContext, GetModule, ModuleResult, ValueOrDefault, ExceptionOrDefault, IsSuccess, IsFailure, IsSkipped, ModuleConfiguration, Configure, WithTimeout, WithRetryCount, WithSkipWhen, WithIgnoreFailures, WithAlwaysRun, CommandExecutionOptions, WorkingDirectory, EnvironmentVariables, Module non-generic, SyncModule, None struct, ExecuteModuleAsync, ExecuteModule, SubModule, context.SubModule, CommandLoggingOptions, CommandLogVerbosity, context.Shell.Command, context.Shell.Bash, context.Shell.PowerShell, DotNetNewOptions, DotNetPackOptions, GitTagOptions, TemplateShortName, property initializer, constructor removed, token parameter"}),"\n",(0,o.jsx)(n.h2,{id:"getting-help",children:"Getting Help"}),"\n",(0,o.jsx)(n.p,{children:"If you encounter issues migrating to V3:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["Check the ",(0,o.jsx)(n.a,{href:"https://github.com/thomhurst/ModularPipelines/issues",children:"GitHub Issues"})," for known migration problems"]}),"\n",(0,o.jsxs)(n.li,{children:["Review the ",(0,o.jsx)(n.a,{href:"https://github.com/thomhurst/ModularPipelines/tree/main/src/ModularPipelines.Examples",children:"Examples"})," for V3 patterns"]}),"\n",(0,o.jsxs)(n.li,{children:["Open a new issue with the ",(0,o.jsx)(n.code,{children:"migration"})," label if you're stuck"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>s});var t=i(6540);const o={},l=t.createContext(o);function r(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);