"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[7579],{6243:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"fundamentals","title":"Fundamentals","description":"Pipeline Builder","source":"@site/docs/fundamentals.md","sourceDirName":".","slug":"/fundamentals","permalink":"/ModularPipelines/docs/fundamentals","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Fundamentals","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Modular Pipelines","permalink":"/ModularPipelines/docs/"},"next":{"title":"How-To","permalink":"/ModularPipelines/docs/category/how-to"}}');var l=t(4848),a=t(8453);const i={title:"Fundamentals",sidebar_position:1},o="Fundamentals",r={},c=[{value:"Pipeline Builder",id:"pipeline-builder",level:2},{value:"Modules",id:"modules",level:2},{value:"Strong Typing",id:"strong-typing",level:2},{value:"Custom Types",id:"custom-types",level:2},{value:"Optional Data",id:"optional-data",level:2},{value:"Automatic Parallelisation and Explicit Dependencies",id:"automatic-parallelisation-and-explicit-dependencies",level:2},{value:"Checking a Module&#39;s Status",id:"checking-a-modules-status",level:2}];function d(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"fundamentals",children:"Fundamentals"})}),"\n",(0,l.jsx)(n.h2,{id:"pipeline-builder",children:"Pipeline Builder"}),"\n",(0,l.jsxs)(n.p,{children:["Your pipeline is created using ",(0,l.jsx)(n.code,{children:"Pipeline.CreateBuilder()"}),". This follows the ASP.NET Core minimal API pattern, providing direct access to ",(0,l.jsx)(n.code,{children:"Configuration"}),", ",(0,l.jsx)(n.code,{children:"Services"}),", and ",(0,l.jsx)(n.code,{children:"Options"}),". Setup should feel familiar if you've used ASP.NET Core."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"var builder = Pipeline.CreateBuilder(args);\nbuilder.Services.AddModule<MyModule>();\nawait builder.Build().RunAsync();\n"})}),"\n",(0,l.jsx)(n.h2,{id:"modules",children:"Modules"}),"\n",(0,l.jsx)(n.p,{children:"The building blocks of your pipelines are called Modules. Modules can be as big or as small as you decide, though it's recommended to make them as small as possible. That way we can speed up execution by utilizing parallelization and we are able to more clearly see what failed and where it failed."}),"\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"a self-contained unit or item, such as an assembly of electronic components and associated wiring or a segment of computer software, which itself performs a defined task and can be linked with other such units to form a larger system"}),"\n"]}),"\n",(0,l.jsx)(n.p,{children:"Modules can retrieve other modules and access information from them."}),"\n",(0,l.jsx)(n.h2,{id:"strong-typing",children:"Strong Typing"}),"\n",(0,l.jsx)(n.p,{children:"Modules are strongly typed, so we can return clear, concrete objects, and other modules have direct access to those strong objects, without any need for casting or guessing the type, or guessing keys from a dictionary."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"// Get a module's result\nvar myModule = await context.GetModule<MyFirstModule>();\n\n// Access the value using pattern matching (recommended)\nif (myModule is ModuleResult<MyFirstModuleResult>.Success { Value: var result })\n{\n    var string1 = result.MyFirstString;\n    var string2 = result.MySecondString;\n}\n\n// Or use ValueOrDefault for simpler access\nvar string1 = myModule.ValueOrDefault?.MyFirstString;\nvar string2 = myModule.ValueOrDefault?.MySecondString;\n"})}),"\n",(0,l.jsx)(n.h2,{id:"custom-types",children:"Custom Types"}),"\n",(0,l.jsxs)(n.p,{children:["A module isn't restricted to a pre-determined type either. You can pass the ",(0,l.jsx)(n.code,{children:"Type"})," of object that you want to return when you inherit from the base ",(0,l.jsx)(n.code,{children:"Module"})," class:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"public class MyModule : Module<MyCustomClass>\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"public class PingApiModule : Module<HttpResponseMessage>\n"})}),"\n",(0,l.jsxs)(n.p,{children:["You'll then be instructed by the compiler to make sure the return type of your main ",(0,l.jsx)(n.code,{children:"ExecuteAsync"})," method matches the ",(0,l.jsx)(n.code,{children:"Type"})," you've set up:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"protected override async Task<MyCustomClass?> ExecuteAsync(IModuleContext context, CancellationToken cancellationToken)\n"})}),"\n",(0,l.jsx)(n.h2,{id:"optional-data",children:"Optional Data"}),"\n",(0,l.jsxs)(n.p,{children:["You can use ",(0,l.jsx)(n.code,{children:"IDictionary<string, object>"})," as a flexible return type:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'public class MyModule : Module<IDictionary<string, object>>\n{\n    protected override async Task<IDictionary<string, object>?> ExecuteAsync(\n        IModuleContext context, CancellationToken cancellationToken)\n    {\n        return new Dictionary<string, object>\n        {\n            ["key1"] = "value1",\n            ["key2"] = 42\n        };\n    }\n}\n'})}),"\n",(0,l.jsxs)(n.p,{children:["Returning an object isn't mandatory either. You can return ",(0,l.jsx)(n.code,{children:"null"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"protected override async Task<MyResult?> ExecuteAsync(\n    IModuleContext context, CancellationToken cancellationToken)\n{\n    await DoSomethingAsync();\n    return null;\n}\n"})}),"\n",(0,l.jsx)(n.h2,{id:"automatic-parallelisation-and-explicit-dependencies",children:"Automatic Parallelisation and Explicit Dependencies"}),"\n",(0,l.jsx)(n.p,{children:"Modules will all try to run in parallel if possible. But if a Module depends on another Module, it is smart enough to automatically wait for the dependent module to finish before executing."}),"\n",(0,l.jsx)(n.p,{children:"Dependencies are configured by adding an attribute on your Module. This also makes it clear to navigate through your pipeline, as with your IDE/Intellisense, you can click through to other Modules with ease."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'[DependsOn<MyOtherModule>]\npublic class MyModule : Module<string>\n{\n    protected override async Task<string?> ExecuteAsync(\n        IModuleContext context, CancellationToken cancellationToken)\n    {\n        // MyOtherModule is guaranteed to have completed before this runs\n        return "result";\n    }\n}\n'})}),"\n",(0,l.jsx)(n.h2,{id:"checking-a-modules-status",children:"Checking a Module's Status"}),"\n",(0,l.jsxs)(n.p,{children:["When you get another Module, you'll be passed a ",(0,l.jsx)(n.code,{children:"ModuleResult<T>"})," that contains the data you returned, as well as information about its execution. Use pattern matching to handle different outcomes:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'var myModule = await context.GetModule<MyOptionalModule>();\n\n// Pattern matching (recommended)\nreturn myModule switch\n{\n    ModuleResult<MyOptionalResult>.Success { Value: var result }\n        => await ProcessResult(result),\n    ModuleResult.Skipped { Decision: var skip }\n        => null,  // Module was skipped\n    ModuleResult.Failure { Exception: var ex }\n        => throw new Exception("Dependency failed", ex),\n    _ => null\n};\n'})}),"\n",(0,l.jsx)(n.p,{children:"Or use the convenience properties for simpler checks:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:'var myModule = await context.GetModule<MyOptionalModule>();\n\nif (myModule.IsSkipped)\n{\n    return null;\n}\n\nif (myModule.IsFailure)\n{\n    // Check the exception\n    if (myModule.ExceptionOrDefault is ItemAlreadyExistsException)\n    {\n        return null;\n    }\n    throw new Exception("Unexpected failure", myModule.ExceptionOrDefault);\n}\n\n// Success case\nreturn await DoSomethingAsync(myModule.ValueOrDefault);\n'})}),"\n",(0,l.jsxs)(n.p,{children:["You can also use the ",(0,l.jsx)(n.code,{children:"Match"})," helper for exhaustive handling:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-csharp",children:"var myModule = await context.GetModule<MyOptionalModule>();\n\nreturn await myModule.Match(\n    onSuccess: result => ProcessResultAsync(result),\n    onFailure: ex => HandleFailureAsync(ex),\n    onSkipped: skip => Task.FromResult<MyResult?>(null)\n);\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const l={},a=s.createContext(l);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);