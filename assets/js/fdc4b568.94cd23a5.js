"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[285],{5199:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>a});var n=t(4848),i=t(8453);const r={title:"Retry Policies",sidebar_position:6},l="Retry Policies",s={id:"how-to/retry-policy",title:"Retry Policies",description:"When creating modules, you can set a retry policy per module by overriding the RetryPolicy property. The retry policy uses a Polly policy, so if you've used Polly before you should be familiar with how to use it.",source:"@site/docs/how-to/retry-policy.md",sourceDirName:"how-to",slug:"/how-to/retry-policy",permalink:"/ModularPipelines/docs/how-to/retry-policy",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"Retry Policies",sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Run conditions",permalink:"/ModularPipelines/docs/how-to/run-conditions"},next:{title:"Skipping Modules",permalink:"/ModularPipelines/docs/how-to/skipping"}},c={},a=[{value:"Default",id:"default",level:2},{value:"Example",id:"example",level:2},{value:"Default Example",id:"default-example",level:2}];function u(e){const o={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(o.header,{children:(0,n.jsx)(o.h1,{id:"retry-policies",children:"Retry Policies"})}),"\n",(0,n.jsxs)(o.p,{children:["When creating modules, you can set a retry policy per module by overriding the ",(0,n.jsx)(o.code,{children:"RetryPolicy"})," property. The retry policy uses a Polly policy, so if you've used Polly before you should be familiar with how to use it.\nIf not, Polly have their own documentation that should help you with this."]}),"\n",(0,n.jsx)(o.h2,{id:"default",children:"Default"}),"\n",(0,n.jsxs)(o.p,{children:["Retry policies are off by default, unless you set a default retry count on the ",(0,n.jsx)(o.code,{children:"PipelineOptions"})," when you're using the ",(0,n.jsx)(o.code,{children:"PipelineHostBuilder"}),". If you set a retry count, for example, 3, then all modules that fail will attempt to retry 3 times. This can be useful for when transient failures occur. You can of course combine this with overriding specific modules for more control."]}),"\n",(0,n.jsx)(o.h2,{id:"example",children:"Example"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-csharp",children:"public class MyModule : Module\n{\n    protected override AsyncRetryPolicy<IDictionary<string, object>?> RetryPolicy { get; }\n        = Policy<IDictionary<string, object>?>\n            .Handle<HttpRequestException>()\n            .WaitAndRetryAsync(5, i => TimeSpan.FromSeconds(i * i));\n\n    protected override Task<IDictionary<string, object>?> ExecuteAsync(IPipelineContext context, CancellationToken cancellationToken)\n    {\n        // Do something\n    }\n}\n"})}),"\n",(0,n.jsx)(o.h2,{id:"default-example",children:"Default Example"}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-csharp",children:"await PipelineHostBuilder.Create()\n    .AddModule<Module1>()\n    .AddModule<Module2>()\n    .AddModule<Module3>()\n    .ConfigurePipelineOptions((context, options) =>\n    {\n        options.DefaultRetryCount = 3;\n    })\n    .ExecutePipelineAsync();\n\n"})})]})}function d(e={}){const{wrapper:o}={...(0,i.R)(),...e.components};return o?(0,n.jsx)(o,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}},8453:(e,o,t)=>{t.d(o,{R:()=>l,x:()=>s});var n=t(6540);const i={},r=n.createContext(i);function l(e){const o=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function s(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),n.createElement(r.Provider,{value:o},e.children)}}}]);