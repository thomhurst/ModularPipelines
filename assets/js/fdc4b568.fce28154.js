"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[285],{5199:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var n=o(4848),i=o(8453);const r={title:"Retry Policies"},l="Retry Policies",s={id:"how-to/retry-policy",title:"Retry Policies",description:"When creating modules, you can set a retry policy per module by overriding the RetryPolicy property. The retry policy uses a Polly policy, so if you've used Polly before you should be familiar with how to use it.",source:"@site/docs/how-to/retry-policy.md",sourceDirName:"how-to",slug:"/how-to/retry-policy",permalink:"/ModularPipelines/docs/how-to/retry-policy",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Retry Policies"},sidebar:"tutorialSidebar",previous:{title:"Requirements",permalink:"/ModularPipelines/docs/how-to/requirements"},next:{title:"Run conditions",permalink:"/ModularPipelines/docs/how-to/run-conditions"}},c={},u=[{value:"Default",id:"default",level:2},{value:"Example",id:"example",level:2},{value:"Default Example",id:"default-example",level:2}];function a(e){const t={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"retry-policies",children:"Retry Policies"}),"\n",(0,n.jsxs)(t.p,{children:["When creating modules, you can set a retry policy per module by overriding the ",(0,n.jsx)(t.code,{children:"RetryPolicy"})," property. The retry policy uses a Polly policy, so if you've used Polly before you should be familiar with how to use it.\nIf not, Polly have their own documentation that should help you with this."]}),"\n",(0,n.jsx)(t.h2,{id:"default",children:"Default"}),"\n",(0,n.jsxs)(t.p,{children:["Retry policies are off by default, unless you set a default retry count on the ",(0,n.jsx)(t.code,{children:"PipelineOptions"})," when you're using the ",(0,n.jsx)(t.code,{children:"PipelineHostBuilder"}),". If you set a retry count, for example, 3, then all modules that fail will attempt to retry 3 times. This can be useful for when transient failures occur. You can of course combine this with overriding specific modules for more control."]}),"\n",(0,n.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-csharp",children:"public class MyModule : Module\n{\n    protected override AsyncRetryPolicy<IDictionary<string, object>?> RetryPolicy { get; }\n        = Policy<IDictionary<string, object>?>\n            .Handle<HttpRequestException>()\n            .WaitAndRetryAsync(5, i => TimeSpan.FromSeconds(i * i));\n\n    protected override Task<IDictionary<string, object>?> ExecuteAsync(IPipelineContext context, CancellationToken cancellationToken)\n    {\n        // Do something\n    }\n}\n"})}),"\n",(0,n.jsx)(t.h2,{id:"default-example",children:"Default Example"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-csharp",children:"await PipelineHostBuilder.Create()\n    .AddModule<Module1>()\n    .AddModule<Module2>()\n    .AddModule<Module3>()\n    .ConfigurePipelineOptions((context, options) =>\n    {\n        options.DefaultRetryCount = 3;\n    })\n    .ExecutePipelineAsync();\n\n"})})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(a,{...e})}):a(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>l,x:()=>s});var n=o(6540);const i={},r=n.createContext(i);function l(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);