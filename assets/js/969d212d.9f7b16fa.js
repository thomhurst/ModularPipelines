"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[656],{1155:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var i=t(4848),a=t(8453);const o={sidebar_position:5},r="Why Modular Pipelines?",s={id:"why",title:"Why Modular Pipelines?",description:"C# / .NET",source:"@site/docs/why.md",sourceDirName:".",slug:"/why",permalink:"/ModularPipelines/docs/why",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Fully Orchestrated Example",permalink:"/ModularPipelines/docs/examples/example"}},l={},d=[{value:"C# / .NET",id:"c--net",level:2},{value:"Source Control",id:"source-control",level:2},{value:"Running locally",id:"running-locally",level:2},{value:"Portability",id:"portability",level:2}];function u(e){const n={h1:"h1",h2:"h2",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"why-modular-pipelines",children:"Why Modular Pipelines?"}),"\n",(0,i.jsx)(n.h2,{id:"c--net",children:"C# / .NET"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"The .NET ecosystem is rich with features and libraries. You can utilize what already exists and not have to re-invent the wheel."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"If you're already a .NET developer, you don't have to concern yourself as much with the different features, languages or syntaxes of different build systems. No need for YAML-based pipeline definitions, Powershell scripts, bash scripts, or even just unfamiliar UI based build systems."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Strong typing - We can structure our modules with objects that we can pass around, and we know what data we then have available to use."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"source-control",children:"Source Control"}),"\n",(0,i.jsx)(n.p,{children:"Some Pipelines, such as TeamCity, aren't typically source controlled. They're built from within the UI itself. This means that making changes for a new feature that isn't released yet has to happen globally, which can cause build breakages between different branches. With it in Source Control, we can change the pipeline on a branch for a new feature without affecting other builds and branches. This makes testing easier and doesn't degrade your production deployments."}),"\n",(0,i.jsx)(n.p,{children:"A broken pipeline shouldn't ever get merged into the main branch if it never went green. A pipeline change should be made via a pull request, and require a successful build in order to merge."}),"\n",(0,i.jsx)(n.p,{children:"We are able to easily look back at a history of changes if they're all stored in git commits"}),"\n",(0,i.jsx)(n.p,{children:"We are easily able to identify who made what changes"}),"\n",(0,i.jsx)(n.h2,{id:"running-locally",children:"Running locally"}),"\n",(0,i.jsx)(n.p,{children:"Many build systems, such as TeamCity and Azure DevOps require running pipelines on their remote agents, and then waiting for a result and parsing through the build output if anything went wrong. It can be very trial-and-error, with lots of lengthy re-runs when trying to debug something.\nBecause ModularPipelines is not tied to a specific build system, it can be run anywhere that has the .NET SDK installed. That includes your developer machine. So as long as you have adequate permissions, you can debug a pipeline locally on your machine. You get all the benefits of the .NET debugger, so we can view in-memory values, and access exceptions, etc. This makes for a much quicker feedback loop!"}),"\n",(0,i.jsx)(n.p,{children:"Because a pipeline can be run locally, there's nothing to stop you from creating a 'local developer pipeline'.\nHow many times have you started a new role or team, and been provided a huge developer setup guide that requires you to download and install numerous different things? You could define a pipeline for local machines. You can decide in startup, depending on something like the Environment name, and decide to either register modules for setting up a local developer machine, or if on a build agent, for deploying to the cloud."}),"\n",(0,i.jsx)(n.h2,{id:"portability",children:"Portability"}),"\n",(0,i.jsx)(n.p,{children:"Want to move to a different build system? You don't have to re-learn or setup the whole thing from scratch. Your system simply needs access to your Pipeline project and have the .NET SDK installed."})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var i=t(6540);const a={},o=i.createContext(a);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);